# This heuristic is generated by [ReEvo](https://github.com/ai4co/reevo) and run by GPT-4o.
# In order to be compatible with the framework, we modified the function name and interface while keeping the core of the algorithm. 

import numpy as np

import numpy as np

def heuristic_reevo(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Normalize the distance matrix
    max_distance = np.max(distance_matrix)
    normalized_distance_matrix = distance_matrix / max_distance if max_distance else distance_matrix

    # Adjusted weights
    weights = {
        "distance_to_current": 0.35,
        "average_distance_to_unvisited": 0.3,
        "std_dev_distance_to_unvisited": 0.25,
        "distance_to_destination": 0.1
    }

    scores = {}
    for node in unvisited_nodes:
        future_distances = [normalized_distance_matrix[node, i] for i in unvisited_nodes if i != node]
        if future_distances:
            average_distance_to_unvisited = sum(future_distances) / len(future_distances)
            std_dev_distance_to_unvisited = (sum((x - average_distance_to_unvisited) ** 2 for x in future_distances) / len(
                future_distances)) ** 0.5
        else:
            average_distance_to_unvisited = std_dev_distance_to_unvisited = 0
        
        # Calculate score
        score = (
            weights["distance_to_current"] * normalized_distance_matrix[current_node, node] -
            weights["average_distance_to_unvisited"] * average_distance_to_unvisited +
            weights["std_dev_distance_to_unvisited"] * std_dev_distance_to_unvisited -
            weights["distance_to_destination"] * normalized_distance_matrix[destination_node, node]
        )

        scores[node] = score

    # Select the next node with the minimum score
    next_node = min(scores, key=scores.get)
    return next_node