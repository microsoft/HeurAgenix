# This heuristic is generated by [ReEvo](https://github.com/ai4co/reevo) and run by GPT-4o.
# In order to be compatible with the framework, we modified the function name and interface while keeping the core of the algorithm. 

import numpy as np

import numpy as np

def heuristic_reevo(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int, alpha=1.0, beta=1.0, gamma=1.0) -> np.ndarray:
    num_nodes = distance_matrix.shape[0]
    # Calculate the inverse of the distance matrix
    inverse_distance_matrix = np.divide(1, distance_matrix, where=(distance_matrix != 0))
    # Calculate total demand and average demand
    total_demand = np.sum(demands)
    average_demand = total_demand / num_nodes
    # Calculate the distance from each node to the starting depot
    depot_distances = distance_matrix[:, 0]
    # Calculate the remaining capacity of the vehicle for each node
    remaining_capacity = capacity - demands
    # Initialize the heuristic matrix
    heuristic_matrix = np.zeros_like(distance_matrix)
    # Calculate the demand factor and distance factor
    demand_factor = demands / total_demand
    normalized_distance = distance_matrix / np.max(distance_matrix)
    distance_factor = depot_distances / (normalized_distance + np.finfo(float).eps)
    
    # Dynamic balancing parameter based on unvisited nodes
    dynamic_balance = (num_nodes - np.arange(num_nodes)) / num_nodes

    # Iterate over each node
    for i in range(num_nodes):
        # Calculate the heuristic value based on distance and capacity constraints
        heuristic_values = (inverse_distance_matrix[i] ** alpha) * (1 / (normalized_distance[i] ** beta))
        # Adjust the heuristic values based on the remaining capacity
        heuristic_values = np.where(remaining_capacity >= demands[i], heuristic_values, 0)
        # Adjust the heuristic values based on the demand factor
        heuristic_values *= (demand_factor[i] / average_demand) ** gamma
        # Adjust the heuristic values based on the distance factor
        heuristic_values *= distance_factor[i]
        heuristic_values[0] = 0  # Exclude the depot node
        # Adjust the heuristic values based on the capacity utilization
        utilization_factor = np.where(remaining_capacity >= demands[i], capacity - demands[i], 0)
        heuristic_values *= utilization_factor
        # Apply dynamic balancing
        heuristic_values *= dynamic_balance[i]
        # Set the heuristic values for the current node in the heuristic matrix
        heuristic_matrix[i] = heuristic_values
        
    return heuristic_matrix