# This heuristic is generated by [EoH](https://github.com/FeiLiu36/EoH) and run by GPT-4o.
# In order to be compatible with the framework, we modified the function name and interface while keeping the core of the algorithm. 

import numpy as np

def heuristic_eoh(edge_distance, local_opt_tour, edge_n_used):
    updated_edge_distance = np.copy(edge_distance)
    edge_count = np.zeros_like(edge_distance)
    
    # Count the usage of each edge in the local optimal tour
    for i in range(len(local_opt_tour) - 1):
        start = local_opt_tour[i]
        end = local_opt_tour[i + 1]
        edge_count[start][end] += 1
        edge_count[end][start] += 1
    
    edge_n_used_max = np.max(edge_n_used)
    mean_distance = np.mean(edge_distance)
    
    # Parameters for noise and decay
    decay_factor = 0.05  # Adjusted decay factor
    edge_use_weight = 0.3  # Weight for edge usage in penalty
    
    for i in range(edge_distance.shape[0]):
        for j in range(edge_distance.shape[1]):
            if edge_count[i][j] > 0:
                # Refined noise factor calculation
                noise_factor = (np.random.normal(1.0, 0.1) / edge_count[i][j]) + (edge_distance[i][j] / mean_distance) - (edge_use_weight / edge_n_used_max) * edge_n_used[i][j]
                
                # Prevent over-penalty by capping the adjustment
                adjustment = noise_factor * (1 + edge_count[i][j])
                max_adjustment = edge_distance[i][j] * 0.5  # Allow up to 50% adjustment
                adjustment = np.clip(adjustment, -max_adjustment, max_adjustment)
                
                # Update with decay
                updated_edge_distance[i][j] += adjustment - decay_factor * updated_edge_distance[i][j]
    
    return updated_edge_distance