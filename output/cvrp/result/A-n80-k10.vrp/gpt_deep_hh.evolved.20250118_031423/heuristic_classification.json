[
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.\nIn this conversation, I will introduce the problem and then framework we have built now, you just remember this.\nIn next conversation, I will describe the challenges I'm encountering and explore how we can collaborate to resolve them.\n\nCurrently, I am working on cvrp problem:\nCapacitated Vehicle Routing Problem (CVRP) is an optimization challenge focused on determining the most efficient routes for a fleet of vehicles to deliver goods to various locations, considering vehicle capacity constraints.\n\nTo support different heuristic algorithms, I build the Solution and Operator framework.\nThe Solution is designed as:\nclass Solution:\n    \"\"\"The solution of CVRP.\nA list of lists where each sublist represents a vehicle's route.\nEach sublist contains integers representing the nodes (customers) visited by the vehicle in the order of visitation.\nThe routes are sorted by vehicle identifier and the nodes in the list sorted by visited order.\"\"\"\n    def __init__(self, routes: list[list[int]], depot: int):\n        self.routes = routes\n        self.depot = depot\nOperator servers as a mechanism to modify solution, which enables the application of heuristic algorithms.\u00a0\nTo support heuristic algorithm, we have build the following operators:\nclass AppendOperator(BaseOperator):\n    \"\"\"Append a node at the end of the specified vehicle's route.\"\"\"\n    def __init__(self, vehicle_id: int, node: int):\n        self.vehicle_id = vehicle_id\n        self.node = node\n    def run(self, solution: Solution) -> Solution:\n        new_routes = [route[:] for route in solution.routes]\n        new_routes[self.vehicle_id].append(self.node)\n        return Solution(new_routes, solution.depot)\nclass InsertOperator(BaseOperator):\n    \"\"\"Insert a node at a specified position within the route of a specified vehicle.\"\"\"\n    def __init__(self, vehicle_id: int, node: int, position: int):\n        self.vehicle_id = vehicle_id\n        self.node = node\n        self.position = position\n    def run(self, solution: Solution) -> Solution:\n        new_routes = [route[:] for route in solution.routes]\n        new_routes[self.vehicle_id].insert(self.position, self.node)\n        return Solution(new_routes, solution.depot)\nclass SwapOperator(BaseOperator):\n    \"\"\"Swap two nodes between or within vehicle routes.\"\"\"\n    def __init__(self, vehicle_id1: int, position1: int, vehicle_id2: int, position2: int):\n        if vehicle_id1 <= vehicle_id2:\n            self.vehicle_id1 = vehicle_id1\n            self.position1 = position1\n            self.vehicle_id2 = vehicle_id2\n            self.position2 = position2\n        else:\n            self.vehicle_id1 = vehicle_id2\n            self.position1 = position2\n            self.vehicle_id2 = vehicle_id1\n            self.position2 = position1\n    def run(self, solution: Solution) -> Solution:\n        new_routes = [route[:] for route in solution.routes]\n        (new_routes[self.vehicle_id1][self.position1], new_routes[self.vehicle_id2][self.position2]) = (new_routes[self.vehicle_id2][self.position2], new_routes[self.vehicle_id1][self.position1])\n        return Solution(new_routes, solution.depot)\nclass ReverseSegmentOperator(BaseOperator):\n    \"\"\"Reverse multiple segments of indices in the solution.\"\"\"\n    def __init__(self, vehicle_id: int, segments: list[tuple[int, int]]):\n        self.vehicle_id = vehicle_id\n        self.segments = segments\n    def run(self, solution: Solution) -> Solution:\n        new_routes = [route[:] for route in solution.routes]\n        new_route = new_routes[self.vehicle_id][:]\n        for segment in self.segments:\n            (start_index, end_index) = segment\n            assert 0 <= start_index < len(new_routes[self.vehicle_id])\n            assert 0 <= end_index < len(new_routes[self.vehicle_id])\n            if start_index <= end_index:\n                new_route[start_index:end_index + 1] = reversed(new_route[start_index:end_index + 1])\n            else:\n                new_route = list(reversed(new_route[start_index:])) + new_route[end_index + 1:start_index] + list(reversed(new_route[:end_index + 1]))\n        new_routes = solution.routes[:self.vehicle_id] + [new_route] + solution.routes[self.vehicle_id + 1:]\n        return Solution(new_routes, solution.depot)\nclass RelocateOperator(BaseOperator):\n    \"\"\"Move a node from one position in a route to another, possibly in a different route.\"\"\"\n    def __init__(self, source_vehicle_id: int, source_position: int, target_vehicle_id: int, target_position: int):\n        self.source_vehicle_id = source_vehicle_id\n        self.source_position = source_position\n        self.target_vehicle_id = target_vehicle_id\n        self.target_position = target_position\n    def run(self, solution: Solution) -> Solution:\n        new_routes = [route[:] for route in solution.routes]\n        node = new_routes[self.source_vehicle_id].pop(self.source_position)\n        if not new_routes[self.target_vehicle_id]:\n            new_routes[self.target_vehicle_id].append(node)\n        else:\n            new_routes[self.target_vehicle_id].insert(self.target_position, node)\n        return Solution(new_routes, solution.depot)\nclass MergeRoutesOperator(BaseOperator):\n    \"\"\"Merge two routes by appending the route of the source vehicle to the beginning of the route of the target vehicle. \nThe merged route is assigned to the target vehicle, and the source vehicle's route is cleared.\"\"\"\n    def __init__(self, source_vehicle_id: int, target_vehicle_id: int):\n        self.source_vehicle_id = source_vehicle_id\n        self.target_vehicle_id = target_vehicle_id\n    def run(self, solution: Solution) -> Solution:\n        new_routes = [route[:] for route in solution.routes]\n        source_depot_index = solution.routes[self.source_vehicle_id].index(solution.depot)\n        target_depot_index = solution.routes[self.target_vehicle_id].index(solution.depot)\n        merge_route = new_routes[self.source_vehicle_id][source_depot_index + 1:] + new_routes[self.source_vehicle_id][:source_depot_index] + new_routes[self.target_vehicle_id][target_depot_index + 1:] + new_routes[self.target_vehicle_id][:target_depot_index]\n        new_routes[self.target_vehicle_id] = [solution.depot] + merge_route + [solution.depot]\n        new_routes[self.source_vehicle_id] = [solution.depot]\n        return Solution(new_routes, solution.depot)\n\nIn pursuit of augmenting our heuristic algorithmic suite, we require the following standardized heuristic function signature:\ndef heuristic(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: call, **kwargs) -> tuple[TargetOperatorType, dict]:\nThe inputs are:\nglobal_data (dict): The global data dict containing the global instance data with:\n    - \"node_num\" (int): The total number of nodes in the problem.\n    - \"distance_matrix\" (numpy.ndarray): A 2D array representing the distances between nodes.\n    - \"vehicle_num\" (int): The total number of vehicles.\n    - \"capacity\" (int): The capacity for each vehicle and all vehicles share the same value.\n    - \"depot\" (int): The index for depot node.\n    - \"demands\" (numpy.ndarray): The demand of each node.\nstate_data (dict): The state data dict containing the solution state data with:\n    - \"current_solution\" (Solution): The current set of routes for all vehicles.\n    - \"visited_nodes\" (list[int]): A list of lists representing the nodes visited by each vehicle.\n    - \"visited_num\" (int): Number of nodes visited by each vehicle.\n    - \"unvisited_nodes\" (list[int]): Nodes that have not yet been visited by any vehicle.\n    - \"visited_num\" (int): Number of nodes have not been visited by each vehicle.\n    - \"total_current_cost\" (int): The total cost of the current solution.\n    - \"last_visited\" (list[int]): The last visited node for each vehicle.\n    - \"vehicle_loads\" (list[int]): The current load of each vehicle.\n    - \"vehicle_remaining_capacity\" (list[int]): The remaining capacity for each vehicle.\n    - \"validation_solution\" (callable): def validation_solution(solution: Solution) -> bool: function to check whether new solution is valid.\nalgorithm_data(dict): Algorithm data contains the data that necessary for some algorithms.\nget_state_data_function(callable): The get_state_data_function is the function that receives the new solution as input and return the state dictionary for new solution. It will not modify the origin solution.\nOther hyper-parameters in kwargs.\nThe outputs includes the operator that must be an instance of a predefined target operator type and updated algorithm dict, which contains new information for future work for both this or other algorithm.\n\nPlease consider is cvrp a combinatorial operation problem and can be solved by heuristics?\nIf you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***is_cop:yes/no***\nEnsure there is no other content inside the ***, and analysis outside *** are welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***is_cop:yes***"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "We have already implement the following heuristics.\nThese are the heuristics inb format: heuristic_name(parameter=default_value, ..): introduction\nfrom src.problems.cvrp.components import *\nimport numpy as np\n\ndef farthest_insertion_6308(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[InsertOperator, dict]:\n    \"\"\" Farthest Insertion Heuristic Algorithm with Improvements for the Capacitated Vehicle Routing Problem (CVRP).\n\n    This heuristic algorithm selects unvisited nodes based on a scoring mechanism that considers insertion cost, route compactness, and vehicle capacity utilization. It periodically performs greedy improvements and inter-vehicle swaps to enhance the solution.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - distance_matrix (numpy.ndarray): 2D array representing the distances between nodes.\n            - demands (numpy.ndarray): Array of demands for each node.\n            - capacity (int): Capacity of each vehicle.\n            - depot (int): Index of the depot node.\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - current_solution (Solution): Current routes for all vehicles.\n            - unvisited_nodes (list[int]): Nodes not yet visited by any vehicle.\n            - last_visited (list[int or None]): Last visited node for each vehicle.\n            - vehicle_remaining_capacity (list[int]): Remaining capacity for each vehicle.\n        algorithm_data (dict): Algorithm-specific data, updated with any new information during execution.\n        get_state_data_function (callable): Function to evaluate the state of a new solution without modifying the original state.\n        kwargs: Hyper-parameters for the heuristic algorithm.\n            - spread_penalty_weight (float, default=1.0): Weight for penalizing spread in the scoring mechanism.\n            - capacity_utilization_weight (float, default=1.0): Weight for vehicle capacity utilization in the scoring mechanism.\n            - apply_greedy_frequency (int, default=3): Frequency of performing greedy improvements.\n            - apply_swap_frequency (int, default=5): Frequency of performing inter-vehicle swaps.\n\n    Returns:\n        InsertOperator: The operator to insert the chosen node into the current solution.\n        dict: Updated algorithm data.\n    \"\"\"\n    # Extract required data\n    distance_matrix = global_data[\"distance_matrix\"]\n    demands = global_data[\"demands\"]\n    capacity = global_data[\"capacity\"]\n    depot = global_data[\"depot\"]\n\n    current_solution = state_data[\"current_solution\"]\n    unvisited_nodes = state_data[\"unvisited_nodes\"]\n    last_visited = state_data[\"last_visited\"]\n    vehicle_remaining_capacity = state_data[\"vehicle_remaining_capacity\"]\n\n    # Hyper-parameters\n    spread_penalty_weight = kwargs.get(\"spread_penalty_weight\", 0.2)\n    capacity_utilization_weight = kwargs.get(\"capacity_utilization_weight\", 0.5)\n    apply_greedy_frequency = kwargs.get(\"apply_greedy_frequency\", 5)\n    apply_swap_frequency = kwargs.get(\"apply_swap_frequency\", 5)\n\n    # Check if there are no unvisited nodes\n    if not unvisited_nodes:\n        return None, {}\n\n    # Step 1: Scoring mechanism to prioritize unvisited nodes\n    best_score = float('inf')\n    best_node = None\n    best_vehicle = None\n    best_position = None\n    operator = None\n\n    for node in unvisited_nodes:\n        for vehicle_id, remaining_capacity in enumerate(vehicle_remaining_capacity):\n            if demands[node] > remaining_capacity:\n                continue\n\n            # Try inserting the node at all possible positions in the vehicle's route\n            route = current_solution.routes[vehicle_id]\n            for position in range(len(route) + 1):\n                prev_node = depot if position == 0 else route[position - 1]\n                next_node = depot if position == len(route) else route[position]\n\n                # Calculate the cost increase for this insertion\n                cost_increase = (\n                    distance_matrix[prev_node][node] +\n                    distance_matrix[node][next_node] -\n                    distance_matrix[prev_node][next_node]\n                )\n\n                # Calculate the penalty for spread (distance from depot to farthest node in the route)\n                farthest_distance = max(\n                    [distance_matrix[depot][n] for n in route + [node] if route] + [0]\n                )\n                spread_penalty = spread_penalty_weight * farthest_distance\n\n                # Factor in vehicle capacity utilization\n                capacity_utilization_penalty = capacity_utilization_weight * (1 - remaining_capacity / capacity)\n\n                # Combine the metrics into a single score\n                score = cost_increase + spread_penalty + capacity_utilization_penalty\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n                    best_vehicle = vehicle_id\n                    best_position = position\n    if best_node is not None and best_vehicle is not None and best_position is not None:\n        # Perform the insertion\n        operator = InsertOperator(best_vehicle, best_node, best_position)\n\n    # Step 2: Periodic greedy improvement\n    if len(unvisited_nodes) % apply_greedy_frequency == 0:\n        best_delta = 0\n        best_vehicle = None\n        best_segment = None\n\n        for vehicle_id, route in enumerate(current_solution.routes):\n            if len(route) < 2:\n                continue\n\n            # Evaluate all 2-opt swaps for compactness\n            for i in range(len(route) - 1):\n                for j in range(i + 2, len(route)):\n                    if j == len(route) - 1 and i == 0:\n                        continue\n\n                    before = distance_matrix[route[(i - 1) % len(route)]][route[i]]\n                    after = distance_matrix[route[j]][route[(j - 1) % len(route)]]\n                    new_before = distance_matrix[route[(i - 1) % len(route)]][route[(j - 1) % len(route)]]\n                    new_after = distance_matrix[route[j]][route[i]]\n                    delta = (new_before + new_after) - (before + after)\n\n                    if delta < best_delta:\n                        best_delta = delta\n                        best_vehicle = vehicle_id\n                        best_segment = (i, j)\n\n        if best_vehicle is not None and best_segment is not None:\n            i, j = best_segment\n            operator = ReverseSegmentOperator(best_vehicle, [(i, j - 1)])\n\n    # Step 3: Periodic inter-vehicle swapping\n    if len(unvisited_nodes) % apply_swap_frequency == 0:\n        best_cost_reduction = float('-inf')\n        best_source_vehicle_id = None\n        best_source_position = None\n        best_target_vehicle_id = None\n        best_target_position = None\n\n        for source_vehicle_id, source_route in enumerate(current_solution.routes):\n            for source_position, node in enumerate(source_route):\n                # Skip if no nodes to shift and avoid shift depot\n                if not source_route or node == depot:\n                    continue\n\n                # Calculate the load after removing the node\n                new_load_source = vehicle_remaining_capacity[source_vehicle_id] + demands[node]\n                if new_load_source > capacity:\n                    continue  # Skip if moving the node violates source vehicle's capacity\n\n                # Check each target route to find the best shift\n                for target_vehicle_id, target_route in enumerate(current_solution.routes):\n                    if source_vehicle_id == target_vehicle_id:\n                        continue\n\n                    new_load_target = vehicle_remaining_capacity[target_vehicle_id] - demands[node]\n                    if new_load_target < 0:\n                        continue  # Skip if moving the node violates target vehicle's capacity\n\n                    for target_position in range(len(target_route) + 1):\n                            # Calculate the cost difference if the node is inserted at the target position\n                            source_previous_node = source_route[(source_position - 1) % len(source_route)]\n                            source_next_node = source_route[(source_position + 1) % len(source_route)]\n                            target_previous_node = target_route[(target_position - 1) % len(target_route)]\n                            target_next_node = target_route[target_position % len(target_route)]\n\n                            cost_increase = (\n                                -distance_matrix[source_previous_node][node]\n                                -distance_matrix[node][source_next_node]\n                                +distance_matrix[source_previous_node][source_next_node]\n                                +distance_matrix[target_previous_node][node]\n                                +distance_matrix[node][target_next_node]\n                                -distance_matrix[target_previous_node][target_next_node]\n                            )\n                            cost_reduction = -cost_increase\n\n                            # Update best shift if this shift is better\n                            if cost_reduction > best_cost_reduction:\n                                best_source_vehicle_id = source_vehicle_id\n                                best_source_position = source_position\n                                best_target_vehicle_id = target_vehicle_id\n                                best_target_position = target_position\n                                best_cost_reduction = cost_reduction\n\n        # If a beneficial swap is found, return the corresponding operator\n        if best_cost_reduction > 0:\n            return RelocateOperator(\n                source_vehicle_id=best_source_vehicle_id,\n                source_position=best_source_position,\n                target_vehicle_id=best_target_vehicle_id,\n                target_position=best_target_position\n            ), {}\n\n    if operator:\n        return operator, {}\n    # If no valid insertion was found\n    return None, {}\nfrom src.problems.cvrp.components import *\nimport numpy as np\n\ndef min_cost_insertion_3b2b(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[InsertOperator, dict]:\n    \"\"\" Optimized Min-Cost Insertion Heuristic for CVRP.\n\n    This heuristic algorithm is optimized for performance by restructuring the order of operations, adjusting hyper-parameters, and implementing efficient logic to enhance the solution.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - distance_matrix (numpy.ndarray): 2D array representing distances between nodes.\n            - demands (numpy.ndarray): Array of demands for each node.\n            - capacity (int): Capacity of each vehicle.\n            - depot (int): Index of the depot node.\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - current_solution (Solution): Current routes for all vehicles.\n            - unvisited_nodes (list[int]): Nodes not yet visited by any vehicle.\n            - last_visited (list[int]): Last visited node for each vehicle.\n            - vehicle_remaining_capacity (list[int]): Remaining capacity for each vehicle.\n        kwargs: Hyper-parameters for the heuristic algorithm.\n            - spread_penalty_weight (float, default=0.05): Weight for penalizing spread in the scoring mechanism.\n            - apply_greedy_frequency (int, default=4): Frequency of performing greedy improvements.\n            - apply_swap_frequency (int, default=6): Frequency of performing inter-vehicle swaps.\n            - high_demand_threshold (int, default=5): Threshold for considering the number of unvisited nodes as low.\n\n    Returns:\n        InsertOperator: The operator to insert the chosen node into the current solution.\n        dict: Updated algorithm data.\n    \"\"\"\n    # Extract required data\n    distance_matrix = global_data[\"distance_matrix\"]\n    demands = global_data[\"demands\"]\n    capacity = global_data[\"capacity\"]\n    depot = global_data[\"depot\"]\n\n    current_solution = state_data[\"current_solution\"]\n    unvisited_nodes = state_data[\"unvisited_nodes\"]\n    vehicle_remaining_capacity = state_data[\"vehicle_remaining_capacity\"]\n\n    # Hyper-parameters\n    spread_penalty_weight = kwargs.get(\"spread_penalty_weight\", 0.05)\n    apply_greedy_frequency = kwargs.get(\"apply_greedy_frequency\", 3)\n    apply_swap_frequency = kwargs.get(\"apply_swap_frequency\", 5)\n    high_demand_threshold = kwargs.get(\"high_demand_threshold\", 5)\n\n    # Check if there are no unvisited nodes\n    if not unvisited_nodes:\n        return None, {}\n\n    # Step 2: Periodic greedy improvement\n    if len(unvisited_nodes) % apply_greedy_frequency == 0:\n        best_delta = 0\n        best_vehicle = None\n        best_segment = None\n\n        for vehicle_id, route in enumerate(current_solution.routes):\n            if len(route) < 2:\n                continue\n\n            # Evaluate all 2-opt swaps for compactness\n            for i in range(len(route) - 1):\n                for j in range(i + 2, len(route)):\n                    if j == len(route) - 1 and i == 0:\n                        continue\n\n                    before = distance_matrix[route[(i - 1) % len(route)]][route[i]]\n                    after = distance_matrix[route[j]][route[(j - 1) % len(route)]]\n                    new_before = distance_matrix[route[(i - 1) % len(route)]][route[(j - 1) % len(route)]]\n                    new_after = distance_matrix[route[j]][route[i]]\n                    delta = (new_before + new_after) - (before + after)\n\n                    if delta < best_delta:\n                        best_delta = delta\n                        best_vehicle = vehicle_id\n                        best_segment = (i, j)\n\n        if best_vehicle is not None and best_segment is not None:\n            i, j = best_segment\n            return ReverseSegmentOperator(best_vehicle, [(i, j - 1)]), {}\n\n    # Step 3: Periodic inter-vehicle swapping\n    if len(unvisited_nodes) % apply_swap_frequency == 0:\n        best_cost_reduction = float('-inf')\n        best_source_vehicle_id = None\n        best_source_position = None\n        best_target_vehicle_id = None\n        best_target_position = None\n\n        for source_vehicle_id, source_route in enumerate(current_solution.routes):\n            for source_position, node in enumerate(source_route):\n                if not source_route or node == depot:\n                    continue\n\n                # Calculate the load after removing the node\n                new_load_source = vehicle_remaining_capacity[source_vehicle_id] + demands[node]\n                if new_load_source > capacity:\n                    continue\n\n                # Check each target route to find the best shift\n                for target_vehicle_id, target_route in enumerate(current_solution.routes):\n                    if source_vehicle_id == target_vehicle_id:\n                        continue\n\n                    new_load_target = vehicle_remaining_capacity[target_vehicle_id] - demands[node]\n                    if new_load_target < 0:\n                        continue\n\n                    for target_position in range(len(target_route) + 1):\n                            # Calculate the cost difference if the node is inserted at the target position\n                            source_previous_node = source_route[(source_position - 1) % len(source_route)]\n                            source_next_node = source_route[(source_position + 1) % len(source_route)]\n                            target_previous_node = target_route[(target_position - 1) % len(target_route)]\n                            target_next_node = target_route[target_position % len(target_route)]\n\n                            cost_increase = (\n                                -distance_matrix[source_previous_node][node]\n                                -distance_matrix[node][source_next_node]\n                                +distance_matrix[source_previous_node][source_next_node]\n                                +distance_matrix[target_previous_node][node]\n                                +distance_matrix[node][target_next_node]\n                                -distance_matrix[target_previous_node][target_next_node]\n                            )\n                            cost_reduction = -cost_increase\n\n                            # Update best shift if this shift is better\n                            if cost_reduction > best_cost_reduction:\n                                best_source_vehicle_id = source_vehicle_id\n                                best_source_position = source_position\n                                best_target_vehicle_id = target_vehicle_id\n                                best_target_position = target_position\n                                best_cost_reduction = cost_reduction\n\n        if best_cost_reduction > 0:\n            return RelocateOperator(\n                source_vehicle_id=best_source_vehicle_id,\n                source_position=best_source_position,\n                target_vehicle_id=best_target_vehicle_id,\n                target_position=best_target_position\n            ), {}\n\n\n    # Step 1: Prioritize nodes based on demands and distances\n    best_score = float('inf')\n    best_node = None\n    best_vehicle = None\n    best_position = None\n\n    for node in unvisited_nodes:\n        for vehicle_id, remaining_capacity in enumerate(vehicle_remaining_capacity):\n            if demands[node] > remaining_capacity:\n                continue\n\n            # Try inserting the node at all possible positions in the vehicle's route\n            route = current_solution.routes[vehicle_id]\n            for position in range(len(route) + 1):\n                prev_node = depot if position == 0 else route[position - 1]\n                next_node = depot if position == len(route) else route[position]\n\n                # Calculate the cost increase for this insertion\n                cost_increase = (\n                    distance_matrix[prev_node][node] +\n                    distance_matrix[node][next_node] -\n                    distance_matrix[prev_node][next_node]\n                )\n\n                # Calculate the penalty for spread (distance from depot to farthest node in the route)\n                farthest_distance = max(\n                    [distance_matrix[depot][n] for n in route + [node]] if route else [distance_matrix[depot][node]]\n                )\n                spread_penalty = spread_penalty_weight * farthest_distance\n\n                # Combine the metrics into a single score\n                score = cost_increase + spread_penalty\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n                    best_vehicle = vehicle_id\n                    best_position = position\n    if best_node is not None and best_vehicle is not None and best_position is not None:\n        return InsertOperator(best_vehicle, best_node, best_position), {}\n\n    # If no valid insertion was found\n    return None, {}\nfrom src.problems.cvrp.components import *\nimport numpy as np\n\ndef nearest_neighbor_54a9(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[InsertOperator, dict]:\n    \"\"\" Enhanced Nearest Neighbor Heuristic for CVRP.\n\n    This heuristic prioritizes nodes with higher demands that can fit into the vehicle's remaining capacity, especially when the number of unvisited nodes is low. It also periodically applies a 2-opt heuristic to improve route compactness.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - distance_matrix (numpy.ndarray): 2D array representing distances between nodes.\n            - demands (numpy.ndarray): Array of demands for each node.\n            - capacity (int): Capacity of each vehicle.\n            - depot (int): Index of the depot node.\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - current_solution (Solution): Current routes for all vehicles.\n            - unvisited_nodes (list[int]): Nodes not yet visited by any vehicle.\n            - last_visited (list[int]): Last visited node for each vehicle.\n            - vehicle_remaining_capacity (list[int]): Remaining capacity for each vehicle.\n        get_state_data_function (callable): Function to calculate state data for a new solution.\n        **kwargs: Hyper-parameters for the heuristic algorithm.\n            - high_demand_threshold (int, default=6): Threshold for considering the number of unvisited nodes as low.\n\n    Returns:\n        InsertOperator: Operator to insert the chosen node into the current solution.\n        dict: Updated algorithm data if any.\n    \"\"\"\n    # Extract required data\n    distance_matrix = global_data[\"distance_matrix\"]\n    demands = global_data[\"demands\"]\n    capacity = global_data[\"capacity\"]\n    depot = global_data[\"depot\"]\n\n    current_solution = state_data[\"current_solution\"]\n    unvisited_nodes = state_data[\"unvisited_nodes\"]\n    last_visited = state_data[\"last_visited\"]\n    vehicle_remaining_capacity = state_data[\"vehicle_remaining_capacity\"]\n\n    # Hyper-parameters\n    high_demand_threshold = kwargs.get(\"high_demand_threshold\", 6)\n\n    # Check if there are no unvisited nodes\n    if not unvisited_nodes:\n        return None, {}\n\n    # Check if the current solution is empty\n    if all(len(route) == 0 for route in current_solution.routes):\n        # Start with the node with the highest demand that can fit into any vehicle\n        highest_demand_node = max(unvisited_nodes, key=lambda node: demands[node])\n        for vehicle_id, remaining_capacity in enumerate(vehicle_remaining_capacity):\n            if demands[highest_demand_node] <= remaining_capacity:\n                return InsertOperator(vehicle_id, highest_demand_node, 0), {}\n\n    # Prioritize nodes with higher demands when unvisited nodes are below the threshold\n    if len(unvisited_nodes) <= high_demand_threshold:\n        best_cost_increase = float('inf')\n        best_node = None\n        best_vehicle = None\n        best_position = None\n\n        for node in unvisited_nodes:\n            for vehicle_id, remaining_capacity in enumerate(vehicle_remaining_capacity):\n                if demands[node] > remaining_capacity:\n                    continue\n\n                # Try inserting the node at all possible positions in the vehicle's route\n                route = current_solution.routes[vehicle_id]\n                for position in range(len(route) + 1):\n                    prev_node = depot if position == 0 else route[position - 1]\n                    next_node = depot if position == len(route) else route[position]\n\n                    cost_increase = (\n                        distance_matrix[prev_node][node] +\n                        distance_matrix[node][next_node] -\n                        distance_matrix[prev_node][next_node]\n                    )\n\n                    if cost_increase < best_cost_increase:\n                        best_cost_increase = cost_increase\n                        best_node = node\n                        best_vehicle = vehicle_id\n                        best_position = position\n\n        if best_node is not None and best_vehicle is not None and best_position is not None:\n            return InsertOperator(best_vehicle, best_node, best_position), {}\n\n    # Default nearest neighbor logic\n    best_cost_increase = float('inf')\n    best_node = None\n    best_vehicle = None\n    best_position = None\n\n    for node in unvisited_nodes:\n        for vehicle_id, remaining_capacity in enumerate(vehicle_remaining_capacity):\n            if demands[node] > remaining_capacity:\n                continue\n\n            # Try inserting the node at all possible positions in the vehicle's route\n            route = current_solution.routes[vehicle_id]\n            for position in range(len(route) + 1):\n                prev_node = depot if position == 0 else route[position - 1]\n                next_node = depot if position == len(route) else route[position]\n\n                cost_increase = (\n                    distance_matrix[prev_node][node] +\n                    distance_matrix[node][next_node] -\n                    distance_matrix[prev_node][next_node]\n                )\n\n                if cost_increase < best_cost_increase:\n                    best_cost_increase = cost_increase\n                    best_node = node\n                    best_vehicle = vehicle_id\n                    best_position = position\n\n    if best_node is not None and best_vehicle is not None and best_position is not None:\n        return InsertOperator(best_vehicle, best_node, best_position), {}\n\n    # If no valid insertion was found\n    return None, {}\nfrom src.problems.cvrp.components import Solution, InsertOperator\n\ndef greedy_f4c4(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[InsertOperator, dict]:\n    \"\"\"\n    Greedy heuristic algorithm for the CVRP.\n    This algorithm attempts to construct a solution by iteratively adding the closest unvisited node to a vehicle's route until all nodes are visited or the vehicle reaches its capacity.\n    It starts with an empty route for each vehicle and selects nodes based on the shortest distance from the last node in the route.\n\n    Args:\n        global_data (dict): Contains the global problem data, including:\n            - \"distance_matrix\" (numpy.ndarray): The distances between nodes.\n            - \"demands\" (numpy.ndarray): The demand of each node.\n            - \"vehicle_num\" (int): The total number of vehicles.\n            - \"capacity\" (int): The capacity for each vehicle.\n        \n        state_data (dict): Contains the current state of the solution, including:\n            - \"unvisited_nodes\" (list[int]): Nodes that have not yet been visited.\n            - \"vehicle_remaining_capacity\" (list[int]): The remaining capacity for each vehicle.\n\n    Returns:\n        InsertOperator: The operator that adds a node to a vehicle's route.\n        dict: Empty dictionary as the algorithm does not update any algorithm-specific data.\n    \"\"\"\n    \n    distance_matrix = global_data['distance_matrix']\n    demands = global_data['demands']\n    vehicle_num = global_data['vehicle_num']\n    vehicle_capacity = global_data['capacity']\n    \n    unvisited_nodes = state_data['unvisited_nodes']\n    vehicle_remaining_capacity = state_data['vehicle_remaining_capacity']\n    \n    # Start with the first unvisited node and the first vehicle\n    for vehicle_id in range(vehicle_num):\n        if not unvisited_nodes or vehicle_remaining_capacity[vehicle_id] <= 0:\n            continue  # Skip to the next vehicle if there are no nodes left or no capacity.\n        \n        # Initialize a temporary variable to find the closest unvisited node\n        closest_node = None\n        closest_distance = float('inf')\n        \n        last_visited_node = 0  # Assuming the depot ID is 0\n        for node in unvisited_nodes:\n            if demands[node] <= vehicle_remaining_capacity[vehicle_id]:\n                distance = distance_matrix[last_visited_node][node]\n                if distance < closest_distance:\n                    closest_distance = distance\n                    closest_node = node\n        \n        if closest_node is not None:\n            # Create an InsertOperator to add this node to the solution\n            return InsertOperator(vehicle_id, closest_node, len(state_data['current_solution'].routes[vehicle_id])), {}\n    \n    # If all nodes are visited or no capacity is left to visit any node, return None\n    return None, {}\nfrom src.problems.cvrp.components import *\n\ndef node_shift_between_routes_7b8a(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[RelocateOperator, dict]:\n    \"\"\"Node Shift Between Routes heuristic for CVRP.\n    This heuristic attempts to move a node from one route to another route, aiming to reduce the total distance or improve load balance.\n    It considers the capacity constraints and ensures that the move is beneficial before applying it.\n\n    Args:\n        global_data (dict): Contains the global information about the problem.\n            - \"distance_matrix\" (numpy.ndarray): The matrix of distances between nodes.\n            - \"capacity\" (int): The capacity for each vehicle.\n            \n        state_data (dict): Contains the current state of the solution.\n            - \"current_solution\" (Solution): The current set of routes.\n            - \"vehicle_loads\" (list[int]): The current load of each vehicle.\n            - \"unvisited_nodes\" (list[int]): Nodes that have not yet been visited.\n            \n        algorithm_data (dict): Contains algorithm-specific data. Not used in this heuristic.\n\n    Returns:\n        (RelocateOperator, dict): The operator to shift a node between routes and an empty dictionary, as the heuristic does not update algorithm_data.\n    \"\"\"\n    # Extract required data from global_data\n    distance_matrix = global_data[\"distance_matrix\"]\n    capacity = global_data[\"capacity\"]\n    depot = global_data[\"depot\"]\n    \n    # Extract required data from state_data\n    current_solution = state_data[\"current_solution\"]\n    vehicle_loads = state_data[\"vehicle_loads\"]\n    # Find the best position to insert the node in the target route\n    best_position = None\n    best_cost_reduction = 0\n    # Find the best node shift between routes\n    for source_vehicle_id, source_route in enumerate(current_solution.routes):\n        for source_position, node in enumerate(source_route):\n            # Skip if no nodes to shift\n            if not source_route or node == depot:\n                continue\n            \n            # Calculate the load after removing the node\n            new_load_source = vehicle_loads[source_vehicle_id] - global_data[\"demands\"][node]\n            if new_load_source < 0:\n                continue  # Skip if moving the node violates source vehicle's capacity\n            \n            # Check each target route to find the best shift\n            for target_vehicle_id, target_route in enumerate(current_solution.routes):\n                # Do not consider the same route\n                if source_vehicle_id == target_vehicle_id:\n                    continue\n                \n                # Calculate the load after adding the node to the target vehicle\n                new_load_target = vehicle_loads[target_vehicle_id] + global_data[\"demands\"][node]\n                if new_load_target > capacity:\n                    continue  # Skip if moving the node violates target vehicle's capacity\n                for target_position in range(len(target_route) + 1):\n                        # Calculate the cost difference if the node is inserted at the target position\n                        source_previous_node = source_route[(source_position - 1) % len(source_route)]\n                        source_next_node = source_route[(source_position + 1) % len(source_route)]\n                        target_previous_node = target_route[(target_position - 1) % len(target_route)]\n                        target_next_node = target_route[target_position % len(target_route)]\n\n                        cost_increase = (\n                            -distance_matrix[source_previous_node][node]\n                            -distance_matrix[node][source_next_node]\n                            +distance_matrix[source_previous_node][source_next_node]\n                            +distance_matrix[target_previous_node][node]\n                            +distance_matrix[node][target_next_node]\n                            -distance_matrix[target_previous_node][target_next_node]\n                        )\n                        cost_reduction = -cost_increase\n\n                        # Update best shift if this shift is better\n                        if cost_reduction > best_cost_reduction:\n                            best_source_vehicle_id = source_vehicle_id\n                            best_source_position = source_position\n                            best_target_vehicle_id = target_vehicle_id\n                            best_target_position = target_position\n                            best_cost_reduction = cost_reduction\n                        \n                \n    # If a beneficial shift is found, return the corresponding operator\n    if best_cost_reduction > 0:\n        return RelocateOperator(\n            source_vehicle_id=best_source_vehicle_id,\n            source_position=best_source_position,\n            target_vehicle_id=best_target_vehicle_id,\n            target_position=best_target_position\n        ), {}\n    \n    # If no beneficial shift is found, return None\n    return None, {}\nfrom src.problems.cvrp.components import Solution, InsertOperator\nimport math\n\ndef petal_algorithm_b384(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[InsertOperator, dict]:\n    \"\"\"\n    Petal construction heuristic algorithm for the CVRP. This heuristic attempts to build feasible routes (petals) around the depot and combine them into a set of vehicle routes.\n    Each petal starts and ends at the depot, creating a loop that can serve as an individual route for a vehicle.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - \"distance_matrix\" (numpy.ndarray): A 2D array representing the distances between nodes.\n            - \"demands\" (numpy.ndarray): The demand of each node.\n            - \"capacity\" (int): The capacity for each vehicle.\n            - \"vehicle_num\" (int): The total number of vehicles.\n            - \"node_num\" (int): The total number of nodes in the problem.\n\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - \"current_solution\" (Solution): The current set of routes for all vehicles.\n            - \"unvisited_nodes\" (list[int]): Nodes that have not yet been visited by any vehicle.\n            - \"vehicle_remaining_capacity\" (list[int]): The remaining capacity for each vehicle.\n\n    Returns:\n        InsertOperator: The operator that adds a node to the route of a vehicle.\n        dict: Updated algorithm data, empty in this case as this heuristic doesn't utilize it.\n    \"\"\"\n\n    distance_matrix = global_data[\"distance_matrix\"]\n    demands = global_data[\"demands\"]\n    vehicle_capacity = global_data[\"capacity\"]\n    vehicle_remaining_capacity = state_data[\"vehicle_remaining_capacity\"].copy()\n    current_solution = state_data[\"current_solution\"].routes\n    unvisited_nodes = state_data[\"unvisited_nodes\"].copy()\n\n    if not unvisited_nodes:\n        # No more nodes to visit, return None.\n        return None, {}\n\n    # Sort nodes based on their polar angle with respect to the depot\n    depot = 0\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: polar_angle(distance_matrix, depot, node))\n\n    # Create petals\n    petals = []\n    for node in sorted_nodes:\n        if demands[node] <= vehicle_capacity:\n            petals.append([node])\n\n    # Try to fit petals into existing vehicle routes\n    for petal in petals:\n        for vehicle_id, route in enumerate(current_solution):\n            if route_fits(petal, vehicle_id, vehicle_remaining_capacity, demands, vehicle_capacity):\n                # If the petal fits, assign it to the vehicle and return the operator\n                return InsertOperator(vehicle_id=vehicle_id, node=petal[0], position=len(route)), {}\n\n    # If no petals fit, return None\n    return None, {}\n\ndef polar_angle(distance_matrix, depot, node):\n    \"\"\"Calculate the polar angle of a node with respect to the depot for sorting.\"\"\"\n    y_diff = distance_matrix[depot][node] - distance_matrix[depot][0]\n    x_diff = distance_matrix[node][depot] - distance_matrix[0][depot]\n    return math.atan2(y_diff, x_diff)\n\ndef route_fits(petal, vehicle_id, vehicle_remaining_capacity, demands, vehicle_capacity):\n    \"\"\"Check if a petal can fit into the current route of a vehicle.\"\"\"\n    # Calculate the total demand of the petal\n    petal_demand = sum(demands[node] for node in petal)\n    # Check if adding the petal would exceed the vehicle's capacity\n    return petal_demand <= vehicle_remaining_capacity[vehicle_id]\nfrom src.problems.cvrp.components import AppendOperator\nimport random\n\ndef random_bfdc(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AppendOperator, dict]:\n    \"\"\"Random heuristic for CVRP.\n    This heuristic selects an unvisited node at random and appends it to a vehicle's route where it does not violate the capacity constraint.\n    This process is repeated for each vehicle until all nodes have been included in a route.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. \n            - \"demands\" (numpy.ndarray): The demand of each node.\n            - \"vehicle_num\" (int): The total number of vehicles.\n            - \"capacity\" (int): The capacity for each vehicle.\n        state_data (dict): The state dictionary containing the current state information.\n            - \"unvisited_nodes\" (list[int]): Nodes that have not yet been visited by any vehicle.\n            - \"vehicle_remaining_capacity\" (list[int]): The remaining capacity for each vehicle.\n            - \"current_solution\" (Solution): The current set of routes for all vehicles.\n\n    Returns:\n        AppendOperator: The operator to append a node to a vehicle's route.\n        dict: Empty dictionary as no algorithm data needs to be updated.\n    \"\"\"\n    unvisited_nodes = state_data['unvisited_nodes']\n    vehicle_remaining_capacity = state_data['vehicle_remaining_capacity']\n    current_solution = state_data['current_solution']\n    demands = global_data['demands']\n    vehicle_num = global_data['vehicle_num']\n    capacity = global_data['capacity']\n\n    # Check if we have any unvisited nodes left\n    if not unvisited_nodes:\n        return None, {}\n\n    # Randomly select an unvisited node\n    node_to_append = random.choice(unvisited_nodes)\n\n    # Find a vehicle that can accommodate the node\n    for _ in range(vehicle_num):\n        vehicle_id = random.randrange(vehicle_num)\n        if vehicle_remaining_capacity[vehicle_id] >= demands[node_to_append]:\n            # Create and return the append operator\n            operator = AppendOperator(vehicle_id=vehicle_id, node=node_to_append)\n            return operator, {}\n\n    # If we reach here, no vehicle can accommodate the node (should not happen if vehicles start empty and capacities are correct)\n    return None, {}\nfrom src.problems.cvrp.components import Solution, MergeRoutesOperator\n\ndef saving_algorithm_710e(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, merge_threshold: float = 0.0, **kwargs) -> tuple[MergeRoutesOperator, dict]:\n    \"\"\" Saving Algorithm heuristic for CVRP.\n    Calculates savings for combining two routes into one for each pair of end nodes of existing routes and sorts these savings in descending order. Routes are then merged by the highest savings while considering vehicle capacity constraints.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - \"distance_matrix\" (numpy.ndarray): The distance matrix between nodes.\n            - \"vehicle_num\" (int): The total number of vehicles.\n            - \"capacity\" (int): The capacity for each vehicle.\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - \"current_solution\" (Solution): The current set of routes for all vehicles.\n            - \"vehicle_loads\" (list[int]): The current load of each vehicle.\n            - \"unvisited_nodes\" (list[int]): Nodes that have not yet been visited by any vehicle.\n        algorithm_data (dict): Not used in this algorithm.\n        merge_threshold (float): A hyperparameter to set the minimum saving value to consider for merging routes. Default is 0.0.\n\n    Returns:\n        MergeRoutesOperator: The chosen operator to merge two routes if a saving above the threshold is found.\n        dict: Empty dictionary as no algorithm_data is updated.\n    \"\"\"\n    distance_matrix = global_data[\"distance_matrix\"]\n    vehicle_capacity = global_data[\"capacity\"]\n    depot = global_data[\"depot\"]\n    vehicle_loads = state_data[\"vehicle_loads\"]\n    current_solution = state_data[\"current_solution\"]\n\n    best_saving = merge_threshold\n    best_operator = None\n\n    for i, route1 in enumerate(current_solution.routes):\n        if not route1:\n            continue\n        for j, route2 in enumerate(current_solution.routes):\n            if i == j or not route2:\n                continue\n            saving = (distance_matrix[route1[-1]][depot] + distance_matrix[depot][route2[0]]) - distance_matrix[route1[-1]][route2[0]]\n            if saving > best_saving and vehicle_loads[i] + vehicle_loads[j] <= vehicle_capacity:\n                best_saving = saving\n                best_operator = MergeRoutesOperator(source_vehicle_id=i, target_vehicle_id=j)\n\n    if best_operator:\n        return best_operator, {}\n    else:\n        # No valid merge found, or all merges have savings below the threshold\n        return None, {}\nfrom src.problems.cvrp.components import *\n\ndef three_opt_e8d7(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[ReverseSegmentOperator, dict]:\n    \"\"\"Implements a 3-opt heuristic algorithm for the Capacitated Vehicle Routing Problem (CVRP).\n\n    Args:\n        global_data (dict): Contains the global data with necessary information like distance_matrix.\n        state_data (dict): Contains the current state information with the current_solution.\n        algorithm_data (dict): Contains the data necessary for this algorithm.\n\n    Returns:\n        TwoOptOperator: The operator that represents the best 2-opt move found.\n        dict: Updated algorithm dictionary.\n    \"\"\"\n    # Retrieve data from global_data and state_data\n    distance_matrix = global_data[\"distance_matrix\"]\n    depot = global_data[\"depot\"]\n    current_solution = state_data[\"current_solution\"]\n\n    # Initialize variables for the best move found\n    best_delta = 0\n    best_move = None\n\n    # Iterate over all routes to apply the 3-opt move\n    for route_index, route in enumerate(current_solution.routes):\n        n = len(route)\n        if n <= 3:\n            continue  # Skip routes that are too short to apply 3-opt\n\n        # Iterate through all combinations of three edges\n        for i in range(n):\n            for j in range(i + 2, n):\n                for k in range(j + 2, n + (1 if i > 0 else 0)):\n                    # Calculate the cost difference for the 3-opt move\n                    moves, delta = calculate_3opt_moves(distance_matrix, route, i, j, k, depot)\n\n                    # Check if this move is better than the best found so far\n                    if delta < best_delta:\n                        best_delta = delta\n                        best_move = (route_index, moves)\n\n    # If a beneficial move is found, create and return the corresponding operator\n    if best_move:\n        route_index, segments = best_move\n        return ReverseSegmentOperator(route_index, segments), algorithm_data\n\n    # If no beneficial move is found, return None\n    return None, algorithm_data\n\ndef calculate_3opt_moves(distance_matrix, route, i, j, k, depot):\n    \"\"\"\n    Calculate the cost difference for all 3-opt reconnection moves for the given segments and return the best move.\n    \"\"\"\n    n = len(route)\n    A = route[(i - 1) % n]\n    B = route[i % n]\n    C = route[(j - 1) % n]\n    D = route[j % n]\n    E = route[(k - 1) % n]\n    F = route[k % n]\n\n    # Calculate the cost of the original segments\n    original_cost = distance_matrix[A][B] + distance_matrix[C][D] + distance_matrix[E][F]\n\n    # Initialize the list of all possible new segments and their costs\n    possible_moves = [\n        (distance_matrix[A][C] + distance_matrix[B][E] + distance_matrix[D][F], [(i % n, (j - 1) % n), (j % n, (k - 1) % n)]),\n        (distance_matrix[F][C] + distance_matrix[B][D] + distance_matrix[E][A], [(i % n, (j - 1) % n), (k % n, (i - 1) % n)]),\n        (distance_matrix[F][B] + distance_matrix[C][E] + distance_matrix[D][A], [(j % n, (k - 1) % n), (k % n, (i - 1) % n)]),\n    ]\n\n\n    # Find the move with the maximum cost reduction\n    best_delta = 0\n    best_move = None\n    for cost, move in possible_moves:\n        delta = cost - original_cost\n        if delta < best_delta:\n            best_delta = delta\n            best_move = move\n\n    # Return the best move and the corresponding cost reduction\n    return best_move, best_delta\nfrom src.problems.cvrp.components import *\n\ndef two_opt_0554(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[ReverseSegmentOperator, dict]:\n    \"\"\"\n    Implements a 2-opt heuristic algorithm for the Capacitated Vehicle Routing Problem (CVRP).\n\n    Args:\n        global_data (dict): Contains the global data with necessary information like distance_matrix.\n        state_data (dict): Contains the current state information with the current_solution.\n        algorithm_data (dict): Contains the data necessary for this algorithm.\n\n    Returns:\n        TwoOptOperator: The operator that represents the best 2-opt move found.\n        dict: Updated algorithm dictionary.\n    \"\"\"\n\n    # Retrieve the necessary data from global_data\n    distance_matrix = global_data[\"distance_matrix\"]\n    node_num = global_data[\"node_num\"]\n    depot = global_data[\"depot\"]\n\n    # Retrieve the current solution from state_data\n    current_solution = state_data[\"current_solution\"]\n    visited_nodes = state_data[\"visited_nodes\"]\n\n    # Initialize variables for the best move found\n    best_delta = 0\n    best_move = None\n\n    # Iterate over all routes to apply the 2-opt move\n    for route_index, route in enumerate(current_solution.routes):\n        for i in range(0, len(route)):\n            for j in range(i + 1, len(route) + 1):\n                # Calculate the cost difference for the current 2-opt move\n                delta = two_opt_cost_change(distance_matrix, route, i, j, depot)\n                # Check if this is the best move so far\n                if delta < best_delta:\n                    best_delta = delta\n                    best_move = (route_index, [(i, j - 1)])\n\n    # If a beneficial move is found, create and return the corresponding operator\n    if best_move:\n        route_index, move_pair = best_move\n        return ReverseSegmentOperator(route_index, move_pair), algorithm_data\n\n    # If no beneficial move is found, return None\n    return None, algorithm_data\n\ndef two_opt_cost_change(distance_matrix, route, i, j, depot):\n    \"\"\"Calculate the cost difference for a 2-opt move.\"\"\"\n    # Assuming the route is a circular tour\n    n = len(route)\n    A = route[(i - 1) % n]\n    B = route[i % n]\n    C = route[(j - 1) % n]\n    D = route[j % n]\n    d0 = distance_matrix[A][B] + distance_matrix[C][D]\n    d1 = distance_matrix[A][C] + distance_matrix[B][D]\n\n    # Return the cost difference\n    return d1 - d0\nfrom src.problems.cvrp.components import *\n\ndef variable_neighborhood_search_614b(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[BaseOperator, dict]:\n    \"\"\" Variable Neighborhood Search heuristic algorithm for CVRP.\n    This function performs a Variable Neighborhood Search by systematically changing the neighborhood structure within a local search algorithm to escape local optima and search for better solutions.\n    It uses a series of pre-defined operators to create new neighborhoods and improve upon the current solution.\n\n    Args:\n        global_data (dict): Global data containing problem parameters.\n            - \"distance_matrix\" (numpy.ndarray): Distance between nodes.\n            - \"vehicle_num\" (int): Number of vehicles.\n            - \"capacity\" (int): Capacity of each vehicle.\n            - \"depot\" (int): Index of the depot node.\n        state_data (dict): State data containing the current state of the solution.\n            - \"current_solution\" (Solution): The current set of routes for all vehicles.\n            - \"vehicle_loads\" (list[int]): The current load of each vehicle.\n            - \"unvisited_nodes\" (list[int]): Nodes that have not yet been visited by any vehicle.\n        algorithm_data (dict): Algorithm-specific data, not used in this heuristic.\n        **kwargs: Hyperparameters for the search, such as the neighborhood size.\n\n    Returns:\n        BaseOperator: The operator that modifies the current solution, or None if no improvement is possible.\n        dict: Empty dictionary as this function does not update algorithm_data.\n    \"\"\"\n\n    # Retrieve necessary data from state_data\n    current_solution = state_data.get('current_solution')\n    vehicle_loads = state_data.get('vehicle_loads')\n    unvisited_nodes = state_data.get('unvisited_nodes')\n\n    # Retrieve necessary data from global_data\n    depot = global_data.get('depot')\n    capacity = global_data.get('capacity')\n    vehicle_num = global_data.get('vehicle_num')\n    distance_matrix = global_data.get('distance_matrix')\n\n    # Define hyperparameters (with default values)\n    neighborhood_size = kwargs.get('neighborhood_size', 10)\n\n    # Initialize variables for the best modification found\n    best_operator = None\n    best_cost_saving = float('inf')\n\n    # Iterate over all possible neighborhoods defined by the neighborhood size\n    for vehicle_id in range(vehicle_num):\n        for node_index in range(len(unvisited_nodes)):\n            node = unvisited_nodes[node_index]\n            # Check if adding this node to the route exceeds the vehicle's capacity\n            if vehicle_loads[vehicle_id] + global_data['demands'][node] <= capacity:\n                for position in range(len(current_solution.routes[vehicle_id]) + 1):\n                    # Calculate the cost of inserting the node at the current position\n                    if position == 0:\n                        before_node = depot\n                    else:\n                        before_node = current_solution.routes[vehicle_id][position - 1]\n                    if position == len(current_solution.routes[vehicle_id]):\n                        after_node = depot\n                    else:\n                        after_node = current_solution.routes[vehicle_id][position]\n                    cost_to_add = distance_matrix[before_node][node] + distance_matrix[node][after_node] - distance_matrix[before_node][after_node]\n\n                    # If the insertion leads to a cost saving, and is better than the previous best saving, store it\n                    if cost_to_add < best_cost_saving:\n                        best_cost_saving = cost_to_add\n                        best_operator = InsertOperator(vehicle_id=vehicle_id, node=node, position=position)\n\n    # Return the best operator found, or None if no improving operator was found\n    return best_operator or None, {}\n\nBefore we solve the actual problem, we hope to select useful algorithms and classify them so that we can use different algorithms in different scenarios. \nWe hope to classify algorithms and use different algorithms in different scenarios. \nPlease note:\n1. We only hope to sort useful and powerful heuristic, some heuristic are not powerful, such pure random heuristic;\n2. One heuristic can belong to multiple classification;\n3. Detailed classification is welcome.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***heuristic_classification:\nclassification1:heuristic_name_1,heuristic_name_2,...;reason\nclassification2:heuristic_name_3,heuristic_name_4,...;reason\n....\n***\nEnsure there is no other content inside the ***, and analysis outside *** are welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***heuristic_classification:\nconstruction_heuristics:farthest_insertion_6308,min_cost_insertion_3b2b,nearest_neighbor_54a9,greedy_f4c4,petal_algorithm_b384;these heuristics build initial solutions by inserting nodes in a specific order or based on specific criteria.\nimprovement_heuristics:three_opt_e8d7,two_opt_0554,variable_neighborhood_search_614b;these heuristics focus on improving existing solutions by exploring neighborhood solutions through different operators.\ninter_route_operators:saving_algorithm_710e,node_shift_between_routes_7b8a;these heuristics focus on moving nodes between different routes to improve the solution quality.\ncapacity_aware_heuristics:farthest_insertion_6308,min_cost_insertion_3b2b,nearest_neighbor_54a9,node_shift_between_routes_7b8a;these heuristics take vehicle capacity into consideration when making decisions.\nrandomized_heuristics:random_bfdc;this heuristic relies on random selection and does not consistently produce high-quality solutions.\n***"
            }
        ]
    }
]