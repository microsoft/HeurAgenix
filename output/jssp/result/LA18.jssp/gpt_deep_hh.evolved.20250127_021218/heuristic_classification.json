[
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.\nIn this conversation, I will introduce the problem and then framework we have built now, you just remember this.\nIn next conversation, I will describe the challenges I'm encountering and explore how we can collaborate to resolve them.\n\nCurrently, I am working on jssp problem:\nJob Shop Scheduling Problem (JSSP) involves scheduling a series of jobs, each comprising a sequence of operations, across different machines to optimize production efficiency. In this variant, there is a one-to-one correspondence between machines and operation types, ensuring that each operation is carried out by a specific machine. Consequently, the number of operations (N) matches the number of machines, and each job includes these N operations precisely once.\n\nTo support different heuristic algorithms, I build the Solution and Operator framework.\nThe Solution is designed as:\nclass Solution:\n    \"\"\"The solution for the Job Shop Scheduling Problem (JSSP).\nA list of lists where each sublist represents the sequence of jobs scheduled on a machine, identified by its index in the outer list.\nEach job is represented by its integer identifier and is processed in the order specified within the sublist.\nEach sublist in 'job_sequences' corresponds to a machine's job processing sequence, with machines sorted by their identifier (index in the outer list).\nEach job within a sublist is sorted by its scheduled order of execution on that machine.\nJob matrix records the target operation(machine) sequence in job.\"\"\"\n    def __init__(self, job_sequences: list[list[int]], job_operation_sequence: list[list[int]], job_operation_index: list[int]):\n        self.job_sequences = job_sequences\n        self.job_operation_sequence = job_operation_sequence\n        self.job_operation_index = job_operation_index\nOperator servers as a mechanism to modify solution, which enables the application of heuristic algorithms.\u00a0\nTo support heuristic algorithm, we have build the following operators:\nclass AdvanceOperator(BaseOperator):\n    \"\"\"AdvanceOperator is responsible for advancing the next operation in the job's processing sequence.\nThis operator appends the next operation of the specified job to the processing queue of the machine that is scheduled to execute the operation.\nIt identifies the appropriate machine based on the job's current operation index and the job matrix within the provided Solution instance.\"\"\"\n    def __init__(self, job_id: int):\n        self.job_id = job_id\n    def run(self, solution: Solution) -> Solution:\n        new_job_sequences = [ops[:] for ops in solution.job_sequences]\n        machine_id = solution.job_operation_sequence[self.job_id][solution.job_operation_index[self.job_id]]\n        new_job_sequences[machine_id].append(self.job_id)\n        job_operation_index = solution.job_operation_index\n        job_operation_index[self.job_id] += 1\n        return Solution(new_job_sequences, solution.job_operation_sequence, job_operation_index)\nclass SwapOperator(BaseOperator):\n    \"\"\"Swaps two operations in corresponding jobs in the same machine's.\"\"\"\n    def __init__(self, machine_id: int, job_id1: int, job_id2: int):\n        self.machine_id = machine_id\n        self.job_id1 = job_id1\n        self.job_id2 = job_id2\n    def run(self, solution: Solution) -> Solution:\n        new_job_sequences = [ops[:] for ops in solution.job_sequences]\n        index1 = new_job_sequences[self.machine_id].index(self.job_id1)\n        index2 = new_job_sequences[self.machine_id].index(self.job_id2)\n        (new_job_sequences[self.machine_id][index1], new_job_sequences[self.machine_id][index2]) = (new_job_sequences[self.machine_id][index2], new_job_sequences[self.machine_id][index1])\n        return Solution(new_job_sequences, solution.job_operation_sequence, solution.job_operation_index)\nclass ReverseSequenceOperator(BaseOperator):\n    \"\"\"Reverses a sequence of operations in corresponding jobs within a machine's queue.\"\"\"\n    def __init__(self, machine_id: int, start_position: int, end_position: int):\n        self.machine_id = machine_id\n        self.start_position = start_position\n        self.end_position = end_position\n    def run(self, solution: Solution) -> Solution:\n        new_job_sequences = [ops[:] for ops in solution.job_sequences]\n        sequence = new_job_sequences[self.machine_id][self.start_position:self.end_position + 1]\n        new_job_sequences[self.machine_id][self.start_position:self.end_position + 1] = sequence[::-1]\n        return Solution(new_job_sequences, solution.job_operation_sequence, solution.job_operation_index)\nclass ShiftOperator(BaseOperator):\n    \"\"\"Shifts an operation to a new position within the same machine's queue.\"\"\"\n    def __init__(self, machine_id: int, job_id: int, new_position: int):\n        self.machine_id = machine_id\n        self.job_id = job_id\n        self.new_position = new_position\n    def run(self, solution: Solution) -> Solution:\n        new_job_sequences = [ops[:] for ops in solution.job_sequences]\n        current_position = new_job_sequences[self.machine_id].index(self.job_id)\n        operation = new_job_sequences[self.machine_id].pop(current_position)\n        new_job_sequences[self.machine_id].insert(self.new_position, operation)\n        return Solution(new_job_sequences, solution.job_operation_sequence, solution.job_operation_index)\n\nIn pursuit of augmenting our heuristic algorithmic suite, we require the following standardized heuristic function signature:\ndef heuristic(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: call, **kwargs) -> tuple[TargetOperatorType, dict]:\nThe inputs are:\nglobal_data (dict): The global data dict containing the global instance data with:\n    - \"job_operation_sequence\" (numpy.ndarray): A list of jobs where each job is a list of operations in target sequence.\n    - \"job_operation_time\" (numpy.ndarray): The time cost for each operation in target job.\n    - \"job_num\" (int): The total number of jobs in the problem.\n    - \"machine_num\" (int): The total number of machines in the problem, also as operation num.\nstate_data (dict): The state data dict containing the solution state data with:\n    - \"current_solution\" (Solution): An instance of the Solution class representing the current solution.\n    - \"finished_jobs\" (list[int]): List of all finished jobs.\n    - \"unfinished_jobs\" (list[int]): List of all unfinished jobs.\n    - \"job_operation_index\" (list[int]): The index of the next operation to be scheduled for each job.\n    - \"job_last_operation_end_times\" (list[int]): The end time of the last operation for each job in current solution.\n    - \"machine_operation_index\" (list[int]): The index of the next operation to be scheduled for each machine.\n    - \"machine_last_operation_end_times\" (list[int]): The end time of the last operation for each machine, also as the available time for next operation.\n    - \"current_makespan\" (int): The time cost for current operation jobs, also known as the current_makespan.\n    - \"validation_solution\" (callable): def validation_solution(solution: Solution) -> bool: function to check whether new solution is valid.\nalgorithm_data(dict): Algorithm data contains the data that necessary for some algorithms.\nget_state_data_function(callable): The get_state_data_function is the function that receives the new solution as input and return the state dictionary for new solution. It will not modify the origin solution.\nOther hyper-parameters in kwargs.\nThe outputs includes the operator that must be an instance of a predefined target operator type and updated algorithm dict, which contains new information for future work for both this or other algorithm.\n\nPlease consider is jssp a combinatorial operation problem and can be solved by heuristics?\nIf you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***is_cop:yes/no***\nEnsure there is no other content inside the ***, and analysis outside *** are welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***is_cop:yes***\n\nThe Job Shop Scheduling Problem (JSSP) is a classic example of a combinatorial optimization problem. It involves finding an optimal order of operations across a set of machines to minimize a given objective, such as makespan or total completion time. Heuristic algorithms are commonly used to solve JSSP due to the problem's complexity and NP-hard nature. Your framework with a Solution class and various Operator classes is well-aligned with typical approaches to addressing such problems using heuristics."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "We have already implement the following heuristics.\nThese are the heuristics inb format: heuristic_name(parameter=default_value, ..): introduction\nfrom src.problems.jssp.components import Solution, AdvanceOperator\n\ndef first_come_first_served_af26(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:\n    \"\"\"Enhanced First Come First Served (FCFS) heuristic to dynamically prioritize jobs based on immediate impact and adapt to diverse datasets.\n    This heuristic introduces a dynamic scoring mechanism to balance alignment with the positive solution trajectory, machine availability, \n    and dataset-specific characteristics.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - \"job_operation_sequence\" (list[list[int]]): A list of jobs where each job is a list of operations in target sequence.\n            - \"machine_num\" (int): Total number of machines in the problem.\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - \"unfinished_jobs\" (list[int]): List of all unfinished jobs.\n            - \"machine_last_operation_end_times\" (list[int]): The end time of the last operation for each machine.\n            - \"job_operation_index\" (list[int]): The index of the next operation to be scheduled for each job.\n            - \"job_last_operation_end_times\" (list[int]): The end time of the last operation for each job.\n            - \"job_diversity\" (int): Diversity of jobs based on the dataset (optional but improves adaptability).\n        algorithm_data (dict): Not used in this heuristic.\n        get_state_data_function (callable): Function to get the state data for a new solution (not used in this heuristic).\n        kwargs (optional): Hyperparameters for fine-tuning:\n            - bias_weight (float, default=50.0): The weight to prioritize jobs aligning with the positive solution trajectory.\n            - diversity_threshold (int, default=5): A threshold to determine when to adapt scoring based on job diversity.\n\n    Returns:\n        AdvanceOperator: The operator that advances the selected job based on priority.\n        dict: Empty dictionary as no algorithm data is updated.\n    \"\"\"\n    \n    # Extract hyperparameters from kwargs with default values\n    bias_weight = kwargs.get(\"bias_weight\", 50.0)\n    diversity_threshold = kwargs.get(\"diversity_threshold\", 5)\n\n    # Check if there are any unfinished jobs. If not, return None.\n    if not state_data[\"unfinished_jobs\"]:\n        return None, {}\n\n    # Extract necessary information from global and state data\n    unfinished_jobs = state_data[\"unfinished_jobs\"]\n    machine_last_end_times = state_data[\"machine_last_operation_end_times\"]\n    job_operation_index = state_data[\"job_operation_index\"]\n    job_last_end_times = state_data[\"job_last_operation_end_times\"]\n    job_operation_sequence = global_data[\"job_operation_sequence\"]\n    job_diversity = state_data.get(\"job_diversity\", 1)  # Default to 1 if not provided\n\n    # Determine if fallback to original FCFS logic is necessary based on dataset characteristics\n    if job_diversity <= diversity_threshold and len(unfinished_jobs) == 1:\n        job_id = unfinished_jobs[0]\n        return AdvanceOperator(job_id=job_id), {}\n\n    # Initialize variables for dynamic priority evaluation\n    best_job = None\n    best_priority_score = float('inf')  # Lower priority score is better\n\n    for job_id in unfinished_jobs:\n        # Determine the machine for the next operation of the job\n        next_machine_id = job_operation_sequence[job_id][job_operation_index[job_id]]\n\n        # Calculate priority score based on machine availability and job alignment\n        priority_score = max(machine_last_end_times[next_machine_id], job_last_end_times[job_id])\n\n        # Introduce a dynamic bias to align with the positive solution trajectory\n        priority_score -= bias_weight / (job_diversity + 1)  # Dynamic adjustment based on diversity\n\n        # Update the best job based on the computed priority score\n        if priority_score < best_priority_score:\n            best_priority_score = priority_score\n            best_job = job_id\n\n    # If no job is selected, return None\n    if best_job is None:\n        return None, {}\n\n    # Create and return the AdvanceOperator for the selected job\n    operator = AdvanceOperator(job_id=best_job)\n    return operator, {}\nfrom src.problems.jssp.components import Solution, AdvanceOperator, SwapOperator, ShiftOperator\n\ndef most_work_remaining_df20(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:\n    \"\"\"Most Work Remaining Heuristic with Dynamic Scoring and Local Optimization for JSSP.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - \"job_operation_sequence\" (list[list[int]]): A list of jobs where each job is a list of operations in their target sequence.\n            - \"job_operation_time\" (list[list[int]]): The time cost for each operation in each job.\n            - \"machine_num\" (int): Total number of machines in the problem.\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - \"unfinished_jobs\" (list[int]): List of all unfinished jobs.\n            - \"machine_last_operation_end_times\" (list[int]): The end time of the last operation for each machine.\n            - \"job_operation_index\" (list[int]): The index of the next operation to be scheduled for each job.\n            - \"job_last_operation_end_times\" (list[int]): The end time of the last operation for each job.\n            - \"current_solution\" (Solution): The current solution state.\n        algorithm_data (dict): The algorithm dictionary for the current algorithm only. In this algorithm, the following items are necessary:\n            - \"iteration\" (int): The current iteration count for the heuristic.\n        get_state_data_function (callable): The function receives the new solution as input and returns the state dictionary for the new solution, without modifying the original solution.\n        kwargs (optional): Hyperparameters for fine-tuning:\n            - bias_weight (float, default=50.0): The weight to prioritize jobs aligning with the positive solution trajectory.\n            - k_flip_frequency (int, default=10): Frequency (iterations) for applying k-flip optimization.\n            - swap_frequency (int, default=10): Frequency (iterations) for applying swap optimization.\n\n    Returns:\n        AdvanceOperator: The operator that advances the selected job based on priority.\n        dict: Updated algorithm data with the new iteration count.\n    \"\"\"\n    # Extract hyperparameters with default values\n    bias_weight = kwargs.get(\"bias_weight\", 40.0)\n    k_flip_frequency = kwargs.get(\"k_flip_frequency\", 10)\n    swap_frequency = kwargs.get(\"swap_frequency\", 10)\n\n    # Get the current iteration from algorithm_data\n    iteration = algorithm_data.get(\"iteration\", 0)\n\n    # Extract necessary data\n    unfinished_jobs = state_data[\"unfinished_jobs\"]\n    machine_last_end_times = state_data[\"machine_last_operation_end_times\"]\n    job_operation_index = state_data[\"job_operation_index\"]\n    job_last_end_times = state_data[\"job_last_operation_end_times\"]\n    job_operation_sequence = global_data[\"job_operation_sequence\"]\n    current_solution = state_data[\"current_solution\"]\n    machine_num = global_data[\"machine_num\"]\n\n    # If no unfinished jobs, return None\n    if not unfinished_jobs:\n        return None, {}\n\n    # Initialize variables for dynamic scoring\n    best_job = None\n    best_score = float(\"inf\")  # Lower score is better\n\n    # Evaluate each unfinished job\n    for job_id in unfinished_jobs:\n        # Get the machine for the next operation of this job\n        next_operation_index = job_operation_index[job_id]\n        if next_operation_index >= len(job_operation_sequence[job_id]):\n            continue  # Skip jobs with no remaining operations\n        next_machine_id = job_operation_sequence[job_id][next_operation_index]\n\n        # Calculate expected machine availability\n        expected_machine_time = max(machine_last_end_times[next_machine_id], job_last_end_times[job_id])\n\n        # Add alignment penalty to prioritize jobs that align better with the optimal trajectory\n        alignment_penalty = bias_weight / (1 + next_operation_index)\n\n        # Calculate total score\n        score = expected_machine_time + alignment_penalty\n        if score < best_score:\n            best_score = score\n            best_job = job_id\n\n    # If no best job is found, return None\n    if best_job is None:\n        return None, {}\n\n    # Apply local optimization periodically\n    if iteration % k_flip_frequency == 0 or iteration % swap_frequency == 0:\n        best_operator = None\n        best_delta = float(\"inf\")\n\n        # Try k-flip optimization\n        for machine_id in range(machine_num):\n            for i in range(len(current_solution.job_sequences[machine_id]) - 2):\n                for j in range(i + 2, len(current_solution.job_sequences[machine_id])):\n                    job_id1 = current_solution.job_sequences[machine_id][i]\n                    job_id2 = current_solution.job_sequences[machine_id][j]\n                    new_solution = SwapOperator(machine_id, job_id1, job_id2).run(current_solution)\n                    new_state = get_state_data_function(new_solution)\n                    if new_state is None:\n                        continue\n                    delta = new_state[\"current_makespan\"] - state_data[\"current_makespan\"]\n                    if delta < best_delta:\n                        best_operator = SwapOperator(machine_id, job_id1, job_id2)\n                        best_delta = delta\n\n        # Try swap optimization\n        for machine_id in range(machine_num):\n            for current_position, job_id in enumerate(current_solution.job_sequences[machine_id]):\n                for new_position in range(len(current_solution.job_sequences[machine_id])):\n                    if current_position == new_position:\n                        continue\n                    new_solution = ShiftOperator(machine_id, job_id, new_position).run(current_solution)\n                    new_state = get_state_data_function(new_solution)\n                    if new_state is None:\n                        continue\n                    delta = new_state[\"current_makespan\"] - state_data[\"current_makespan\"]\n                    if delta < best_delta:\n                        best_operator = ShiftOperator(machine_id, job_id, new_position)\n                        best_delta = delta\n\n        # If a better operator is found, return it\n        if best_operator is not None:\n            return best_operator, {\"iteration\": iteration + 1}\n\n    # Return the best AdvanceOperator\n    return AdvanceOperator(job_id=best_job), {\"iteration\": iteration + 1}\nfrom src.problems.jssp.components import Solution, AdvanceOperator\n\ndef shortest_processing_time_first_d471(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:\n    \"\"\"Shortest Processing Time First with Dynamic Scoring Heuristic for JSSP.\n\n    This heuristic dynamically evaluates unfinished jobs based on their next operation's machine availability,\n    alignment with the optimal trajectory, and a bias factor to guide towards jobs that minimize makespan.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - \"job_operation_sequence\" (list[list[int]]): A list of jobs where each job is a list of operations in their target sequence.\n            - \"job_operation_time\" (list[list[int]]): The time cost for each operation in each job.\n            - \"machine_num\" (int): Total number of machines in the problem.\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - \"unfinished_jobs\" (list[int]): List of all unfinished jobs.\n            - \"machine_last_operation_end_times\" (list[int]): The end time of the last operation for each machine.\n            - \"job_operation_index\" (list[int]): The index of the next operation to be scheduled for each job.\n            - \"job_last_operation_end_times\" (list[int]): The end time of the last operation for each job.\n            - \"current_solution\" (Solution): The current solution state.\n            - \"job_diversity\" (int): Diversity of jobs in the dataset (default to 1 if not provided).\n        algorithm_data (dict): The algorithm dictionary for the current algorithm only. Not used in this heuristic.\n        get_state_data_function (callable): Function to get the state data for a new solution. Not used in this heuristic.\n        kwargs: Optional hyperparameters for fine-tuning:\n            - bias_weight (float, default=50.0): The weight to prioritize jobs aligning with the positive solution trajectory.\n            - diversity_threshold (int, default=5): A threshold to determine when to adapt scoring based on job diversity.\n\n    Returns:\n        AdvanceOperator: The operator that advances the selected job based on priority.\n        dict: An empty dictionary as no algorithm data is updated.\n    \"\"\"\n    \n    # Extract hyperparameters from kwargs with default values\n    bias_weight = kwargs.get(\"bias_weight\", 50.0)\n    diversity_threshold = kwargs.get(\"diversity_threshold\", 5)\n\n    # Check if there are any unfinished jobs. If not, return None.\n    if not state_data[\"unfinished_jobs\"]:\n        return None, {}\n\n    # Extract necessary information from global and state data\n    unfinished_jobs = state_data[\"unfinished_jobs\"]\n    machine_last_end_times = state_data[\"machine_last_operation_end_times\"]\n    job_operation_index = state_data[\"job_operation_index\"]\n    job_last_end_times = state_data[\"job_last_operation_end_times\"]\n    job_operation_sequence = global_data[\"job_operation_sequence\"]\n    job_diversity = state_data.get(\"job_diversity\", 1)  # Default to 1 if not provided\n\n    # Determine if fallback to a simpler logic is necessary based on dataset characteristics\n    if job_diversity <= diversity_threshold and len(unfinished_jobs) == 1:\n        job_id = unfinished_jobs[0]\n        return AdvanceOperator(job_id=job_id), {}\n\n    # Initialize variables for dynamic priority evaluation\n    best_job = None\n    best_priority_score = float('inf')  # Lower priority score is better\n\n    for job_id in unfinished_jobs:\n        # Determine the machine for the next operation of the job\n        next_operation_index = job_operation_index[job_id]\n        if next_operation_index >= len(job_operation_sequence[job_id]):\n            continue  # Skip jobs that have no remaining operations\n        next_machine_id = job_operation_sequence[job_id][next_operation_index]\n\n        # Calculate priority score based on machine availability and job alignment\n        priority_score = max(machine_last_end_times[next_machine_id], job_last_end_times[job_id])\n\n        # Introduce a dynamic bias to prefer jobs that align with the positive solution trajectory\n        priority_score -= bias_weight / (job_diversity + 1)  # Dynamic adjustment based on diversity\n\n        # Update the best job based on the computed priority score\n        if priority_score < best_priority_score:\n            best_priority_score = priority_score\n            best_job = job_id\n\n    # If no job is selected, return None\n    if best_job is None:\n        return None, {}\n\n    # Create and return the AdvanceOperator for the selected job\n    operator = AdvanceOperator(job_id=best_job)\n    return operator, {}\nfrom src.problems.jssp.components import Solution, AdvanceOperator\n\ndef least_work_remaining_66c9(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:\n    \"\"\"\n    Selects the job with the least total processing time remaining from the unfinished jobs and returns an AdvanceOperator to schedule its next operation.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. For this algorithm, we need:\n            - \"job_operation_time\" (numpy.ndarray):  The time cost for each operation in target job.\n        state_data (dict): The state dictionary containing the current state information. For this algorithm, we need:\n            - \"unfinished_jobs\" (list[int]): List of all unfinished jobs.\n            - \"job_operation_index\" (list[int]): The index of the next operation to be scheduled for each job.\n\n    Returns:\n        AdvanceOperator: Operator to advance the selected job's next operation.\n        dict: Empty dictionary as no algorithm data is updated.\n    \"\"\"\n    # Extract necessary information from global_data\n    job_operation_time = global_data[\"job_operation_time\"]\n\n    # Extract necessary state data\n    unfinished_jobs = state_data[\"unfinished_jobs\"]\n    job_operation_index = state_data[\"job_operation_index\"]\n\n    # Initialize the least work remaining and corresponding job ID\n    min_work_remaining = float('inf')\n    job_to_advance = None\n\n    # Iterate over unfinished jobs to find the one with the least work remaining\n    for job_id in unfinished_jobs:\n        remaining_time = sum(job_operation_time[job_id][job_operation_index[job_id]:])\n        if remaining_time < min_work_remaining:\n            min_work_remaining = remaining_time\n            job_to_advance = job_id\n\n    # If no job is found, return None, {}\n    if job_to_advance is None:\n        return None, {}\n\n    # Create and return the AdvanceOperator for the job with the least work remaining\n    return AdvanceOperator(job_to_advance), {}\nfrom src.problems.jssp.components import Solution, AdvanceOperator\n\ndef longest_job_next_2e23(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:\n    \"\"\"Longest Job Next heuristic for JSSP.\n    \n    Prioritizes the job with the longest total processing time remaining. It uses the\n    AdvanceOperator to schedule the next operation for the job with the maximum\n    remaining processing time.\n\n    Args:\n        global_data (dict): Contains global data about the problem.\n            - \"job_operation_time\" (numpy.ndarray):  The time cost for each operation in each job.\n            - \"job_num\" (int): The total number of jobs in the problem.\n            \n        state_data (dict): Contains the current state of the solution.\n            - \"unfinished_jobs\" (list[int]): List of all unfinished jobs.\n            - \"job_operation_index\" (list[int]): The index of the next operation to be scheduled for each job.\n            - \"current_solution\" (Solution): The current state of the job sequences on each machine.\n            \n        algorithm_data (dict): Contains data necessary for this algorithm.\n            (No specific data needed for this algorithm; can be omitted or passed as an empty dict)\n            \n        get_state_data_function (callable): Function that takes a Solution instance and returns its state data.\n        \n        **kwargs: Additional hyperparameters (not used in this algorithm).\n\n    Returns:\n        (AdvanceOperator): The operator to advance the job with the longest processing time remaining.\n        (dict): Empty dictionary as no algorithm data is updated.\n    \"\"\"\n    # Extract necessary data from the global and state dictionaries.\n    job_operation_time = global_data[\"job_operation_time\"]\n    unfinished_jobs = state_data[\"unfinished_jobs\"]\n    job_operation_index = state_data[\"job_operation_index\"]\n    \n    # Check if there are any unfinished jobs. If not, return None.\n    if not unfinished_jobs:\n        return None, {}\n    \n    # Calculate remaining processing time for each unfinished job.\n    remaining_times = {\n        job_id: sum(job_operation_time[job_id][index:])\n        for job_id, index in enumerate(job_operation_index) if job_id in unfinished_jobs\n    }\n    \n    # Find the job with the maximum remaining processing time.\n    job_id_to_schedule = max(remaining_times, key=remaining_times.get)\n    \n    # Create and return the AdvanceOperator for the job with the longest job next.\n    advance_op = AdvanceOperator(job_id=job_id_to_schedule)\n    \n    return advance_op, {}\nfrom src.problems.jssp.components import Solution, AdvanceOperator\n\ndef longest_processing_time_first_9dc9(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:\n    \"\"\"Selects the next job to be scheduled based on the Longest Processing Time (LPT) heuristic.\n    \n    Args:\n        global_data (dict): Contains the global data for the problem.\n            - \"job_operation_time\" (numpy.ndarray):  The time cost for each operation in each job.\n            - \"job_num\" (int): The total number of jobs.\n            - \"machine_num\" (int): The total number of machines.\n        \n        state_data (dict): Contains the current state information.\n            - \"unfinished_jobs\" (list[int]): List of all unfinished jobs.\n            - \"current_solution\" (Solution): The current solution state.\n        \n        algorithm_data (dict): Contains data specific to the algorithm (unused in this heuristic).\n        \n        get_state_data_function (callable): Function to get the state data for a new solution (unused in this heuristic).\n        \n        **kwargs: Additional hyperparameters (unused in this heuristic).\n    \n    Returns:\n        AdvanceOperator: An operator that, when applied to the current solution, advances the longest processing job.\n        dict: An empty dictionary since this heuristic doesn't update algorithm_data.\n    \"\"\"\n    \n    # No additional information from algorithm_data or kwargs is used in this heuristic.\n    \n    # Extract necessary information from global_data\n    job_operation_time = global_data[\"job_operation_time\"]\n    \n    # Extract necessary information from state_data\n    unfinished_jobs = state_data[\"unfinished_jobs\"]\n    current_solution = state_data[\"current_solution\"]\n    \n    # Initialize variables to keep track of the job with the longest next operation time\n    max_time = -1\n    selected_job = None\n    \n    # Iterate through all unfinished jobs to find the job with the longest next operation time\n    for job_id in unfinished_jobs:\n        next_operation_index = current_solution.job_operation_index[job_id]\n        \n        # Check if there is a next operation for the job\n        if next_operation_index < len(job_operation_time[job_id]):\n            next_operation_time = job_operation_time[job_id][next_operation_index]\n            \n            # Update the job with the longest next operation time\n            if next_operation_time > max_time:\n                max_time = next_operation_time\n                selected_job = job_id\n    \n    # If no job is found (all jobs are finished), return None and an empty dictionary\n    if selected_job is None:\n        return None, {}\n    \n    # Create an AdvanceOperator for the job with the longest next operation time\n    operator = AdvanceOperator(selected_job)\n    \n    # Return the operator and an empty dictionary since no algorithm data is updated\n    return operator, {}\nfrom src.problems.jssp.components import Solution, AdvanceOperator\nimport random\n\ndef random_6512(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:\n    \"\"\"This heuristic randomly selects an unfinished job and advances its next operation in the job's processing sequence.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - \"job_num\" (int): The total number of jobs in the problem.\n            - \"machine_num\" (int): The total number of machines in the problem, also as operation num.\n            - \"job_operation_sequence\" (numpy.ndarray): A list of jobs where each job is a list of operations in target sequence.\n            - \"job_operation_time\" (numpy.ndarray):  The time cost for each operation in the target job.\n            - \"total_processing_times\" (list[int]): The total processing time for each machine across all jobs in machine id.\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - \"current_solution\" (Solution): An instance of the Solution class representing the current solution.\n            - \"finished_jobs\" (list[int]): List of all finished jobs.\n            - \"unfinished_jobs\" (list[int]): List of all unfinished jobs.\n            - \"job_operation_index\" (list[int]): The index of the next operation to be scheduled for each job.\n            - \"job_last_operation_end_times\" (list[int]): The end time of the last operation for each job in the current solution.\n            - \"job_states\" (pd.DataFrame): DataFrame for job states, columns=[\"JobID\", \"IsFinished\", \"CompletedOperationsForMachinesInSequence(MachineID,StartTime,EndTime)\", \"RemainingOperationsForMachineInSequence(MachineID)\", \"EndTimeForLastOperation\"]\n            - \"machine_last_operation_end_times\" (list[int]): The end time of the last operation for each machine, also as the available time for next operation.\n            - \"machine_states\" (pd.DataFrame): DataFrame for machine states, columns=[\"MachineID\", \"CompletedOperationsForJobsInSequence(JobID,StartTime,EndTime)\", \"EndTimeForLastOperation\"]\n            - \"current_makespan\" (int): The time cost for current operation jobs, also known as the current_makespan.\n\n    Returns:\n        AdvanceOperator: The operator to advance the next operation for a randomly selected unfinished job.\n        dict: Updated algorithm data (empty in this case).\n    \"\"\"\n    # Check if there are any unfinished jobs\n    unfinished_jobs = state_data[\"unfinished_jobs\"]\n    if not unfinished_jobs:\n        return None, {}\n\n    # Randomly select an unfinished job\n    selected_job = random.choice(unfinished_jobs)\n\n    # Create an AdvanceOperator for the selected job\n    operator = AdvanceOperator(job_id=selected_job)\n\n    # Return the operator and an empty dictionary as no algorithm data is updated\n    return operator, {}\nfrom src.problems.jssp.components import ShiftOperator\n\ndef shift_operator_109f(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[ShiftOperator, dict]:\n    \"\"\"\n    This heuristic attempts to find a better schedule by shifting an operation within the same machine's queue.\n    For each machine, it tries shifting each operation to all possible positions and evaluates the makespan.\n    The shift that results in the best improvement (reduction in makespan) is selected.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - \"machine_num\" (int): The total number of machines.\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - \"current_solution\" (Solution): The current solution state.\n            - \"current_makespan\" (int): The current makespan of the schedule.\n        get_state_data_function (callable): Function to get the new state data given a Solution instance.\n\n    Returns:\n        ShiftOperator: An operator that shifts a job in the schedule to achieve a local improvement.\n        dict: An empty dictionary as this heuristic does not require algorithm data updates.\n    \"\"\"\n\n    current_solution = state_data['current_solution']\n    machine_num = global_data['machine_num']\n    best_operator = None\n    best_delta = float('inf')\n\n    # Iterate over all machines\n    for machine_id in range(machine_num):\n        # Iterate over all operations in the machine's queue\n        for current_position, job_id in enumerate(current_solution.job_sequences[machine_id]):\n            # Try shifting the operation to all possible positions\n            for new_position in range(len(current_solution.job_sequences[machine_id])):\n                # Skip if the position is the same as the current one\n                if current_position == new_position:\n                    continue\n                \n                # Create a new solution with the operation shifted to the new position\n                new_solution = ShiftOperator(machine_id, job_id, new_position).run(current_solution)\n                new_state = get_state_data_function(new_solution)\n                \n                # If the new solution is valid, evaluate its makespan\n                if new_state is not None:\n                    delta = new_state['current_makespan'] - state_data['current_makespan']\n                    \n                    # If the makespan is improved, store this operator\n                    if delta < best_delta:\n                        best_operator = ShiftOperator(machine_id, job_id, new_position)\n                        best_delta = delta\n\n    # If a beneficial shift is found, return the corresponding operator\n    if best_operator and best_delta < 0:\n        return best_operator, {}\n    else:\n        return None, {}\nfrom src.problems.jssp.components import AdvanceOperator\n\ndef shortest_job_next_5b42(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:\n    \"\"\"Implements the Shortest Job Next heuristic for the Job Shop Scheduling Problem.\n    This heuristic chooses the unfinished job with the shortest remaining processing time and advances its next operation.\n\n    Args:\n        global_data (dict): Contains global static information about the problem.\n            - \"job_operation_time\" (numpy.ndarray):  The time cost for each operation in each job.\n            \n        state_data (dict): Contains the current state information of the solution.\n            - \"unfinished_jobs\" (list[int]): List of all unfinished jobs.\n            - \"current_solution\" (Solution): The current solution state.\n            \n        algorithm_data (dict): Contains data necessary for the algorithm's state, not used in this heuristic.\n        get_state_data_function (callable): A function to get the state data for a given solution.\n\n    Returns:\n        AdvanceOperator: The operator to advance the next operation of the selected job.\n        dict: An empty dictionary as this heuristic does not update algorithm data.\n    \"\"\"\n\n    # Retrieve the necessary information from the global and state data\n    job_operation_time = global_data[\"job_operation_time\"]\n    unfinished_jobs = state_data[\"unfinished_jobs\"]\n    job_operation_index = state_data[\"current_solution\"].job_operation_index\n\n    # Check if there are any unfinished jobs\n    if not unfinished_jobs:\n        return None, {}\n\n    # Calculate the total remaining processing time for each unfinished job\n    remaining_times = {job: sum(times[job_operation_index[job]:]) \n                       for job, times in enumerate(job_operation_time) if job in unfinished_jobs}\n\n    # Find the job with the shortest total remaining processing time\n    shortest_job = min(remaining_times, key=remaining_times.get)\n\n    # Generate the operator to advance the selected job\n    operator = AdvanceOperator(job_id=shortest_job)\n\n    return operator, {}\nfrom src.problems.jssp.components import Solution, SwapOperator\n\ndef _2opt_f9c1(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[SwapOperator, dict]:\n    \"\"\"Implements a 2-opt heuristic for the Job Shop Scheduling Problem (JSSP).\n    This heuristic attempts to reduce the makespan by swapping two non-adjacent operations in the schedule.\n    It iteratively checks all possible pairs of operations to determine if a shorter sequence can be found.\n\n    Args:\n        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:\n            - \"job_operation_sequence\" (numpy.ndarray): Each job's sequence of operations.\n            - \"machine_num\" (int): The total number of machines.\n        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:\n            - \"current_solution\" (Solution): The current solution state.\n            - \"job_operation_index\" (list[int]): The index of the next operation to be scheduled for each job.\n\n    Returns:\n        (SwapOperator, dict): A tuple where the first element is the selected operator that performs the best swap found,\n                              and the second element is an empty dictionary since this algorithm does not update algorithm_data.\n    \"\"\"\n    current_solution = state_data['current_solution']\n    job_operation_sequence = global_data['job_operation_sequence']\n    machine_num = global_data['machine_num']\n    best_operator = None\n    best_delta = 0\n\n    # Iterating over all machines and all non-adjacent pairs of jobs within each machine's sequence\n    for machine_id in range(machine_num):\n        for i in range(len(current_solution.job_sequences[machine_id]) - 2):\n            for j in range(i + 2, len(current_solution.job_sequences[machine_id])):\n                job_id1 = current_solution.job_sequences[machine_id][i]\n                job_id2 = current_solution.job_sequences[machine_id][j]\n\n                # Calculate the makespan change if the swap is performed\n                new_solution = SwapOperator(machine_id, job_id1, job_id2).run(current_solution)\n                new_state = get_state_data_function(new_solution)\n                if new_state == None:\n                    continue\n                delta = new_state['current_makespan'] - state_data['current_makespan']\n\n                # Check if this is the best swap found so far\n                if best_operator is None or delta < best_delta:\n                    best_operator = SwapOperator(machine_id, job_id1, job_id2)\n                    best_delta = delta\n\n    # If a beneficial swap is found, return the corresponding operator\n    if best_operator and best_delta < 0:\n        return best_operator, {}\n    else:\n        return None, {}\nfrom src.problems.jssp.components import Solution, SwapOperator\n\ndef _3opt_6ee0(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[SwapOperator, dict]:\n    \"\"\"3-opt heuristic for Job Shop Scheduling Problem (JSSP).\n    This function does not generate a complete 3-opt operator since JSSP requires operations within a job to be executed in sequence and does not allow reordering of these operations.The heuristic is adapted to generate a series of 2-opt swaps (using the SwapOperator) which approximate a 3-opt move.\n\n    Args:\n        global_data (dict): The global data dict containing the global data.\n            - \"machine_num\" (int): The total number of machines.\n            - \"job_num\" (int): The total number of jobs.\n            \n        state_data (dict): The state dictionary containing the current state information.\n            - \"current_solution\" (Solution): The current solution state.\n            - \"unfinished_jobs\" (list[int]): List of all unfinished jobs.\n            - \"machine_last_operation_end_times\" (list[int]): The end time of the last operation for each machine.\n            \n        algorithm_data (dict): Not used in this heuristic.\n        \n        get_state_data_function (callable): Function to get the new state data given a Solution instance.\n    \n    Returns:\n        SwapOperator: The operator to swap two jobs in the schedule.\n        dict: Empty dictionary as no algorithm data is updated.\n    \"\"\"\n    \n    # Check if we have enough jobs to perform a 3-opt move\n    if global_data['job_num'] < 3:\n        return None, {}  # Not enough jobs to perform a 3-opt\n    \n    # Extract necessary information from the state data\n    current_solution = state_data['current_solution']\n    machine_last_operation_end_times = state_data['machine_last_operation_end_times']\n    \n    # Initialize variables to store the best swap operator and its corresponding makespan improvement\n    best_operator = None\n    best_improvement = 0\n    \n    # Iterate over all machines\n    for machine_id in range(global_data['machine_num']):\n        job_sequence = current_solution.job_sequences[machine_id]\n        num_jobs = len(job_sequence)\n        \n        # Need at least three jobs on the machine to consider 3-opt\n        if num_jobs < 3:\n            continue\n        \n        # Consider all triplets of jobs for potential 3-opt moves\n        for i in range(num_jobs - 2):\n            for j in range(i + 1, num_jobs - 1):\n                for k in range(j + 1, num_jobs):\n                    # Perform 2-opt swaps and check for improvement\n                    new_solution = SwapOperator(machine_id, job_sequence[i], job_sequence[k]).run(current_solution)\n                    new_state = get_state_data_function(new_solution)\n                    if new_state == None:\n                        continue\n                    improvement = state_data['current_makespan'] - new_state['current_makespan']\n                    \n                    # Update the best operator if this swap results in a better makespan\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_operator = SwapOperator(machine_id, job_sequence[i], job_sequence[k])\n    \n    # Return the best operator found (if any) and an empty dictionary as no algorithm data is updated\n    return best_operator, {}\n\nBefore we solve the actual problem, we hope to select useful algorithms and classify them so that we can use different algorithms in different scenarios. \nWe hope to classify algorithms and use different algorithms in different scenarios. \nPlease note:\n1. We only hope to sort useful and powerful heuristic, some heuristic are not powerful, such pure random heuristic;\n2. One heuristic can belong to multiple classification;\n3. Detailed classification is welcome.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***heuristic_classification:\nclassification1:heuristic_name_1,heuristic_name_2,...;reason\nclassification2:heuristic_name_3,heuristic_name_4,...;reason\n....\n***\nEnsure there is no other content inside the ***, and analysis outside *** are welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***heuristic_classification:\npriority_based:first_come_first_served_af26,shortest_processing_time_first_d471,least_work_remaining_66c9,shortest_job_next_5b42;these heuristics prioritize jobs based on certain criteria like arrival time, processing time, or work remaining.\ndynamic_scheduling:most_work_remaining_df20,longest_job_next_2e23,longest_processing_time_first_9dc9;these heuristics dynamically evaluate jobs and make decisions based on current system state, often considering factors like job length or work remaining.\nlocal_optimization:_2opt_f9c1,_3opt_6ee0,shift_operator_109f;these heuristics focus on local optimization techniques to improve the schedule by making small changes like swaps or shifts.\n***"
            }
        ]
    }
]