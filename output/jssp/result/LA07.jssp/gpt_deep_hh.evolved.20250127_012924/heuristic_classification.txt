user
I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.
In this conversation, I will introduce the problem and then framework we have built now, you just remember this.
In next conversation, I will describe the challenges I'm encountering and explore how we can collaborate to resolve them.

Currently, I am working on jssp problem:
Job Shop Scheduling Problem (JSSP) involves scheduling a series of jobs, each comprising a sequence of operations, across different machines to optimize production efficiency. In this variant, there is a one-to-one correspondence between machines and operation types, ensuring that each operation is carried out by a specific machine. Consequently, the number of operations (N) matches the number of machines, and each job includes these N operations precisely once.

To support different heuristic algorithms, I build the Solution and Operator framework.
The Solution is designed as:
class Solution:
    """The solution for the Job Shop Scheduling Problem (JSSP).
A list of lists where each sublist represents the sequence of jobs scheduled on a machine, identified by its index in the outer list.
Each job is represented by its integer identifier and is processed in the order specified within the sublist.
Each sublist in 'job_sequences' corresponds to a machine's job processing sequence, with machines sorted by their identifier (index in the outer list).
Each job within a sublist is sorted by its scheduled order of execution on that machine.
Job matrix records the target operation(machine) sequence in job."""
    def __init__(self, job_sequences: list[list[int]], job_operation_sequence: list[list[int]], job_operation_index: list[int]):
        self.job_sequences = job_sequences
        self.job_operation_sequence = job_operation_sequence
        self.job_operation_index = job_operation_index
Operator servers as a mechanism to modify solution, which enables the application of heuristic algorithms.Â 
To support heuristic algorithm, we have build the following operators:
class AdvanceOperator(BaseOperator):
    """AdvanceOperator is responsible for advancing the next operation in the job's processing sequence.
This operator appends the next operation of the specified job to the processing queue of the machine that is scheduled to execute the operation.
It identifies the appropriate machine based on the job's current operation index and the job matrix within the provided Solution instance."""
    def __init__(self, job_id: int):
        self.job_id = job_id
    def run(self, solution: Solution) -> Solution:
        new_job_sequences = [ops[:] for ops in solution.job_sequences]
        machine_id = solution.job_operation_sequence[self.job_id][solution.job_operation_index[self.job_id]]
        new_job_sequences[machine_id].append(self.job_id)
        job_operation_index = solution.job_operation_index
        job_operation_index[self.job_id] += 1
        return Solution(new_job_sequences, solution.job_operation_sequence, job_operation_index)
class SwapOperator(BaseOperator):
    """Swaps two operations in corresponding jobs in the same machine's."""
    def __init__(self, machine_id: int, job_id1: int, job_id2: int):
        self.machine_id = machine_id
        self.job_id1 = job_id1
        self.job_id2 = job_id2
    def run(self, solution: Solution) -> Solution:
        new_job_sequences = [ops[:] for ops in solution.job_sequences]
        index1 = new_job_sequences[self.machine_id].index(self.job_id1)
        index2 = new_job_sequences[self.machine_id].index(self.job_id2)
        (new_job_sequences[self.machine_id][index1], new_job_sequences[self.machine_id][index2]) = (new_job_sequences[self.machine_id][index2], new_job_sequences[self.machine_id][index1])
        return Solution(new_job_sequences, solution.job_operation_sequence, solution.job_operation_index)
class ReverseSequenceOperator(BaseOperator):
    """Reverses a sequence of operations in corresponding jobs within a machine's queue."""
    def __init__(self, machine_id: int, start_position: int, end_position: int):
        self.machine_id = machine_id
        self.start_position = start_position
        self.end_position = end_position
    def run(self, solution: Solution) -> Solution:
        new_job_sequences = [ops[:] for ops in solution.job_sequences]
        sequence = new_job_sequences[self.machine_id][self.start_position:self.end_position + 1]
        new_job_sequences[self.machine_id][self.start_position:self.end_position + 1] = sequence[::-1]
        return Solution(new_job_sequences, solution.job_operation_sequence, solution.job_operation_index)
class ShiftOperator(BaseOperator):
    """Shifts an operation to a new position within the same machine's queue."""
    def __init__(self, machine_id: int, job_id: int, new_position: int):
        self.machine_id = machine_id
        self.job_id = job_id
        self.new_position = new_position
    def run(self, solution: Solution) -> Solution:
        new_job_sequences = [ops[:] for ops in solution.job_sequences]
        current_position = new_job_sequences[self.machine_id].index(self.job_id)
        operation = new_job_sequences[self.machine_id].pop(current_position)
        new_job_sequences[self.machine_id].insert(self.new_position, operation)
        return Solution(new_job_sequences, solution.job_operation_sequence, solution.job_operation_index)

In pursuit of augmenting our heuristic algorithmic suite, we require the following standardized heuristic function signature:
def heuristic(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: call, **kwargs) -> tuple[TargetOperatorType, dict]:
The inputs are:
global_data (dict): The global data dict containing the global instance data with:
    - "job_operation_sequence" (numpy.ndarray): A list of jobs where each job is a list of operations in target sequence.
    - "job_operation_time" (numpy.ndarray): The time cost for each operation in target job.
    - "job_num" (int): The total number of jobs in the problem.
    - "machine_num" (int): The total number of machines in the problem, also as operation num.
state_data (dict): The state data dict containing the solution state data with:
    - "current_solution" (Solution): An instance of the Solution class representing the current solution.
    - "finished_jobs" (list[int]): List of all finished jobs.
    - "unfinished_jobs" (list[int]): List of all unfinished jobs.
    - "job_operation_index" (list[int]): The index of the next operation to be scheduled for each job.
    - "job_last_operation_end_times" (list[int]): The end time of the last operation for each job in current solution.
    - "machine_operation_index" (list[int]): The index of the next operation to be scheduled for each machine.
    - "machine_last_operation_end_times" (list[int]): The end time of the last operation for each machine, also as the available time for next operation.
    - "current_makespan" (int): The time cost for current operation jobs, also known as the current_makespan.
    - "validation_solution" (callable): def validation_solution(solution: Solution) -> bool: function to check whether new solution is valid.
algorithm_data(dict): Algorithm data contains the data that necessary for some algorithms.
get_state_data_function(callable): The get_state_data_function is the function that receives the new solution as input and return the state dictionary for new solution. It will not modify the origin solution.
Other hyper-parameters in kwargs.
The outputs includes the operator that must be an instance of a predefined target operator type and updated algorithm dict, which contains new information for future work for both this or other algorithm.

Please consider is jssp a combinatorial operation problem and can be solved by heuristics?
If you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.

The response format is very important. For better communication, please respond to me in this format:
***is_cop:yes/no***
Ensure there is no other content inside the ***, and analysis outside *** are welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***is_cop:yes***

The Job Shop Scheduling Problem (JSSP) is indeed a combinatorial operation problem and can be effectively approached using heuristic methods. Your framework, which includes a `Solution` class and various operators (such as `AdvanceOperator`, `SwapOperator`, `ReverseSequenceOperator`, and `ShiftOperator`), is consistent with the requirements for solving JSSP using hyper-heuristics. The provided data structures and heuristic function signature are appropriately designed for implementing heuristic algorithms to tackle this problem.
------------------------------------------------------------------------------------

user
We have already implement the following heuristics.
These are the heuristics inb format: heuristic_name(parameter=default_value, ..): introduction
from src.problems.jssp.components import Solution, AdvanceOperator

def first_come_first_served_af26(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:
    """Enhanced First Come First Served (FCFS) heuristic to dynamically prioritize jobs based on immediate impact and adapt to diverse datasets.
    This heuristic introduces a dynamic scoring mechanism to balance alignment with the positive solution trajectory, machine availability, 
    and dataset-specific characteristics.

    Args:
        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:
            - "job_operation_sequence" (list[list[int]]): A list of jobs where each job is a list of operations in target sequence.
            - "machine_num" (int): Total number of machines in the problem.
        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:
            - "unfinished_jobs" (list[int]): List of all unfinished jobs.
            - "machine_last_operation_end_times" (list[int]): The end time of the last operation for each machine.
            - "job_operation_index" (list[int]): The index of the next operation to be scheduled for each job.
            - "job_last_operation_end_times" (list[int]): The end time of the last operation for each job.
            - "job_diversity" (int): Diversity of jobs based on the dataset (optional but improves adaptability).
        algorithm_data (dict): Not used in this heuristic.
        get_state_data_function (callable): Function to get the state data for a new solution (not used in this heuristic).
        kwargs (optional): Hyperparameters for fine-tuning:
            - bias_weight (float, default=50.0): The weight to prioritize jobs aligning with the positive solution trajectory.
            - diversity_threshold (int, default=5): A threshold to determine when to adapt scoring based on job diversity.

    Returns:
        AdvanceOperator: The operator that advances the selected job based on priority.
        dict: Empty dictionary as no algorithm data is updated.
    """
    
    # Extract hyperparameters from kwargs with default values
    bias_weight = kwargs.get("bias_weight", 50.0)
    diversity_threshold = kwargs.get("diversity_threshold", 5)

    # Check if there are any unfinished jobs. If not, return None.
    if not state_data["unfinished_jobs"]:
        return None, {}

    # Extract necessary information from global and state data
    unfinished_jobs = state_data["unfinished_jobs"]
    machine_last_end_times = state_data["machine_last_operation_end_times"]
    job_operation_index = state_data["job_operation_index"]
    job_last_end_times = state_data["job_last_operation_end_times"]
    job_operation_sequence = global_data["job_operation_sequence"]
    job_diversity = state_data.get("job_diversity", 1)  # Default to 1 if not provided

    # Determine if fallback to original FCFS logic is necessary based on dataset characteristics
    if job_diversity <= diversity_threshold and len(unfinished_jobs) == 1:
        job_id = unfinished_jobs[0]
        return AdvanceOperator(job_id=job_id), {}

    # Initialize variables for dynamic priority evaluation
    best_job = None
    best_priority_score = float('inf')  # Lower priority score is better

    for job_id in unfinished_jobs:
        # Determine the machine for the next operation of the job
        next_machine_id = job_operation_sequence[job_id][job_operation_index[job_id]]

        # Calculate priority score based on machine availability and job alignment
        priority_score = max(machine_last_end_times[next_machine_id], job_last_end_times[job_id])

        # Introduce a dynamic bias to align with the positive solution trajectory
        priority_score -= bias_weight / (job_diversity + 1)  # Dynamic adjustment based on diversity

        # Update the best job based on the computed priority score
        if priority_score < best_priority_score:
            best_priority_score = priority_score
            best_job = job_id

    # If no job is selected, return None
    if best_job is None:
        return None, {}

    # Create and return the AdvanceOperator for the selected job
    operator = AdvanceOperator(job_id=best_job)
    return operator, {}
from src.problems.jssp.components import Solution, AdvanceOperator, SwapOperator, ShiftOperator

def most_work_remaining_df20(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:
    """Most Work Remaining Heuristic with Dynamic Scoring and Local Optimization for JSSP.

    Args:
        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:
            - "job_operation_sequence" (list[list[int]]): A list of jobs where each job is a list of operations in their target sequence.
            - "job_operation_time" (list[list[int]]): The time cost for each operation in each job.
            - "machine_num" (int): Total number of machines in the problem.
        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:
            - "unfinished_jobs" (list[int]): List of all unfinished jobs.
            - "machine_last_operation_end_times" (list[int]): The end time of the last operation for each machine.
            - "job_operation_index" (list[int]): The index of the next operation to be scheduled for each job.
            - "job_last_operation_end_times" (list[int]): The end time of the last operation for each job.
            - "current_solution" (Solution): The current solution state.
        algorithm_data (dict): The algorithm dictionary for the current algorithm only. In this algorithm, the following items are necessary:
            - "iteration" (int): The current iteration count for the heuristic.
        get_state_data_function (callable): The function receives the new solution as input and returns the state dictionary for the new solution, without modifying the original solution.
        kwargs (optional): Hyperparameters for fine-tuning:
            - bias_weight (float, default=50.0): The weight to prioritize jobs aligning with the positive solution trajectory.
            - k_flip_frequency (int, default=10): Frequency (iterations) for applying k-flip optimization.
            - swap_frequency (int, default=10): Frequency (iterations) for applying swap optimization.

    Returns:
        AdvanceOperator: The operator that advances the selected job based on priority.
        dict: Updated algorithm data with the new iteration count.
    """
    # Extract hyperparameters with default values
    bias_weight = kwargs.get("bias_weight", 40.0)
    k_flip_frequency = kwargs.get("k_flip_frequency", 10)
    swap_frequency = kwargs.get("swap_frequency", 10)

    # Get the current iteration from algorithm_data
    iteration = algorithm_data.get("iteration", 0)

    # Extract necessary data
    unfinished_jobs = state_data["unfinished_jobs"]
    machine_last_end_times = state_data["machine_last_operation_end_times"]
    job_operation_index = state_data["job_operation_index"]
    job_last_end_times = state_data["job_last_operation_end_times"]
    job_operation_sequence = global_data["job_operation_sequence"]
    current_solution = state_data["current_solution"]
    machine_num = global_data["machine_num"]

    # If no unfinished jobs, return None
    if not unfinished_jobs:
        return None, {}

    # Initialize variables for dynamic scoring
    best_job = None
    best_score = float("inf")  # Lower score is better

    # Evaluate each unfinished job
    for job_id in unfinished_jobs:
        # Get the machine for the next operation of this job
        next_operation_index = job_operation_index[job_id]
        if next_operation_index >= len(job_operation_sequence[job_id]):
            continue  # Skip jobs with no remaining operations
        next_machine_id = job_operation_sequence[job_id][next_operation_index]

        # Calculate expected machine availability
        expected_machine_time = max(machine_last_end_times[next_machine_id], job_last_end_times[job_id])

        # Add alignment penalty to prioritize jobs that align better with the optimal trajectory
        alignment_penalty = bias_weight / (1 + next_operation_index)

        # Calculate total score
        score = expected_machine_time + alignment_penalty
        if score < best_score:
            best_score = score
            best_job = job_id

    # If no best job is found, return None
    if best_job is None:
        return None, {}

    # Apply local optimization periodically
    if iteration % k_flip_frequency == 0 or iteration % swap_frequency == 0:
        best_operator = None
        best_delta = float("inf")

        # Try k-flip optimization
        for machine_id in range(machine_num):
            for i in range(len(current_solution.job_sequences[machine_id]) - 2):
                for j in range(i + 2, len(current_solution.job_sequences[machine_id])):
                    job_id1 = current_solution.job_sequences[machine_id][i]
                    job_id2 = current_solution.job_sequences[machine_id][j]
                    new_solution = SwapOperator(machine_id, job_id1, job_id2).run(current_solution)
                    new_state = get_state_data_function(new_solution)
                    if new_state is None:
                        continue
                    delta = new_state["current_makespan"] - state_data["current_makespan"]
                    if delta < best_delta:
                        best_operator = SwapOperator(machine_id, job_id1, job_id2)
                        best_delta = delta

        # Try swap optimization
        for machine_id in range(machine_num):
            for current_position, job_id in enumerate(current_solution.job_sequences[machine_id]):
                for new_position in range(len(current_solution.job_sequences[machine_id])):
                    if current_position == new_position:
                        continue
                    new_solution = ShiftOperator(machine_id, job_id, new_position).run(current_solution)
                    new_state = get_state_data_function(new_solution)
                    if new_state is None:
                        continue
                    delta = new_state["current_makespan"] - state_data["current_makespan"]
                    if delta < best_delta:
                        best_operator = ShiftOperator(machine_id, job_id, new_position)
                        best_delta = delta

        # If a better operator is found, return it
        if best_operator is not None:
            return best_operator, {"iteration": iteration + 1}

    # Return the best AdvanceOperator
    return AdvanceOperator(job_id=best_job), {"iteration": iteration + 1}
from src.problems.jssp.components import Solution, AdvanceOperator

def shortest_processing_time_first_d471(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:
    """Shortest Processing Time First with Dynamic Scoring Heuristic for JSSP.

    This heuristic dynamically evaluates unfinished jobs based on their next operation's machine availability,
    alignment with the optimal trajectory, and a bias factor to guide towards jobs that minimize makespan.

    Args:
        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:
            - "job_operation_sequence" (list[list[int]]): A list of jobs where each job is a list of operations in their target sequence.
            - "job_operation_time" (list[list[int]]): The time cost for each operation in each job.
            - "machine_num" (int): Total number of machines in the problem.
        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:
            - "unfinished_jobs" (list[int]): List of all unfinished jobs.
            - "machine_last_operation_end_times" (list[int]): The end time of the last operation for each machine.
            - "job_operation_index" (list[int]): The index of the next operation to be scheduled for each job.
            - "job_last_operation_end_times" (list[int]): The end time of the last operation for each job.
            - "current_solution" (Solution): The current solution state.
            - "job_diversity" (int): Diversity of jobs in the dataset (default to 1 if not provided).
        algorithm_data (dict): The algorithm dictionary for the current algorithm only. Not used in this heuristic.
        get_state_data_function (callable): Function to get the state data for a new solution. Not used in this heuristic.
        kwargs: Optional hyperparameters for fine-tuning:
            - bias_weight (float, default=50.0): The weight to prioritize jobs aligning with the positive solution trajectory.
            - diversity_threshold (int, default=5): A threshold to determine when to adapt scoring based on job diversity.

    Returns:
        AdvanceOperator: The operator that advances the selected job based on priority.
        dict: An empty dictionary as no algorithm data is updated.
    """
    
    # Extract hyperparameters from kwargs with default values
    bias_weight = kwargs.get("bias_weight", 50.0)
    diversity_threshold = kwargs.get("diversity_threshold", 5)

    # Check if there are any unfinished jobs. If not, return None.
    if not state_data["unfinished_jobs"]:
        return None, {}

    # Extract necessary information from global and state data
    unfinished_jobs = state_data["unfinished_jobs"]
    machine_last_end_times = state_data["machine_last_operation_end_times"]
    job_operation_index = state_data["job_operation_index"]
    job_last_end_times = state_data["job_last_operation_end_times"]
    job_operation_sequence = global_data["job_operation_sequence"]
    job_diversity = state_data.get("job_diversity", 1)  # Default to 1 if not provided

    # Determine if fallback to a simpler logic is necessary based on dataset characteristics
    if job_diversity <= diversity_threshold and len(unfinished_jobs) == 1:
        job_id = unfinished_jobs[0]
        return AdvanceOperator(job_id=job_id), {}

    # Initialize variables for dynamic priority evaluation
    best_job = None
    best_priority_score = float('inf')  # Lower priority score is better

    for job_id in unfinished_jobs:
        # Determine the machine for the next operation of the job
        next_operation_index = job_operation_index[job_id]
        if next_operation_index >= len(job_operation_sequence[job_id]):
            continue  # Skip jobs that have no remaining operations
        next_machine_id = job_operation_sequence[job_id][next_operation_index]

        # Calculate priority score based on machine availability and job alignment
        priority_score = max(machine_last_end_times[next_machine_id], job_last_end_times[job_id])

        # Introduce a dynamic bias to prefer jobs that align with the positive solution trajectory
        priority_score -= bias_weight / (job_diversity + 1)  # Dynamic adjustment based on diversity

        # Update the best job based on the computed priority score
        if priority_score < best_priority_score:
            best_priority_score = priority_score
            best_job = job_id

    # If no job is selected, return None
    if best_job is None:
        return None, {}

    # Create and return the AdvanceOperator for the selected job
    operator = AdvanceOperator(job_id=best_job)
    return operator, {}
from src.problems.jssp.components import Solution, AdvanceOperator

def least_work_remaining_66c9(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:
    """
    Selects the job with the least total processing time remaining from the unfinished jobs and returns an AdvanceOperator to schedule its next operation.

    Args:
        global_data (dict): The global data dict containing the global data. For this algorithm, we need:
            - "job_operation_time" (numpy.ndarray):  The time cost for each operation in target job.
        state_data (dict): The state dictionary containing the current state information. For this algorithm, we need:
            - "unfinished_jobs" (list[int]): List of all unfinished jobs.
            - "job_operation_index" (list[int]): The index of the next operation to be scheduled for each job.

    Returns:
        AdvanceOperator: Operator to advance the selected job's next operation.
        dict: Empty dictionary as no algorithm data is updated.
    """
    # Extract necessary information from global_data
    job_operation_time = global_data["job_operation_time"]

    # Extract necessary state data
    unfinished_jobs = state_data["unfinished_jobs"]
    job_operation_index = state_data["job_operation_index"]

    # Initialize the least work remaining and corresponding job ID
    min_work_remaining = float('inf')
    job_to_advance = None

    # Iterate over unfinished jobs to find the one with the least work remaining
    for job_id in unfinished_jobs:
        remaining_time = sum(job_operation_time[job_id][job_operation_index[job_id]:])
        if remaining_time < min_work_remaining:
            min_work_remaining = remaining_time
            job_to_advance = job_id

    # If no job is found, return None, {}
    if job_to_advance is None:
        return None, {}

    # Create and return the AdvanceOperator for the job with the least work remaining
    return AdvanceOperator(job_to_advance), {}
from src.problems.jssp.components import Solution, AdvanceOperator

def longest_job_next_2e23(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:
    """Longest Job Next heuristic for JSSP.
    
    Prioritizes the job with the longest total processing time remaining. It uses the
    AdvanceOperator to schedule the next operation for the job with the maximum
    remaining processing time.

    Args:
        global_data (dict): Contains global data about the problem.
            - "job_operation_time" (numpy.ndarray):  The time cost for each operation in each job.
            - "job_num" (int): The total number of jobs in the problem.
            
        state_data (dict): Contains the current state of the solution.
            - "unfinished_jobs" (list[int]): List of all unfinished jobs.
            - "job_operation_index" (list[int]): The index of the next operation to be scheduled for each job.
            - "current_solution" (Solution): The current state of the job sequences on each machine.
            
        algorithm_data (dict): Contains data necessary for this algorithm.
            (No specific data needed for this algorithm; can be omitted or passed as an empty dict)
            
        get_state_data_function (callable): Function that takes a Solution instance and returns its state data.
        
        **kwargs: Additional hyperparameters (not used in this algorithm).

    Returns:
        (AdvanceOperator): The operator to advance the job with the longest processing time remaining.
        (dict): Empty dictionary as no algorithm data is updated.
    """
    # Extract necessary data from the global and state dictionaries.
    job_operation_time = global_data["job_operation_time"]
    unfinished_jobs = state_data["unfinished_jobs"]
    job_operation_index = state_data["job_operation_index"]
    
    # Check if there are any unfinished jobs. If not, return None.
    if not unfinished_jobs:
        return None, {}
    
    # Calculate remaining processing time for each unfinished job.
    remaining_times = {
        job_id: sum(job_operation_time[job_id][index:])
        for job_id, index in enumerate(job_operation_index) if job_id in unfinished_jobs
    }
    
    # Find the job with the maximum remaining processing time.
    job_id_to_schedule = max(remaining_times, key=remaining_times.get)
    
    # Create and return the AdvanceOperator for the job with the longest job next.
    advance_op = AdvanceOperator(job_id=job_id_to_schedule)
    
    return advance_op, {}
from src.problems.jssp.components import Solution, AdvanceOperator

def longest_processing_time_first_9dc9(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:
    """Selects the next job to be scheduled based on the Longest Processing Time (LPT) heuristic.
    
    Args:
        global_data (dict): Contains the global data for the problem.
            - "job_operation_time" (numpy.ndarray):  The time cost for each operation in each job.
            - "job_num" (int): The total number of jobs.
            - "machine_num" (int): The total number of machines.
        
        state_data (dict): Contains the current state information.
            - "unfinished_jobs" (list[int]): List of all unfinished jobs.
            - "current_solution" (Solution): The current solution state.
        
        algorithm_data (dict): Contains data specific to the algorithm (unused in this heuristic).
        
        get_state_data_function (callable): Function to get the state data for a new solution (unused in this heuristic).
        
        **kwargs: Additional hyperparameters (unused in this heuristic).
    
    Returns:
        AdvanceOperator: An operator that, when applied to the current solution, advances the longest processing job.
        dict: An empty dictionary since this heuristic doesn't update algorithm_data.
    """
    
    # No additional information from algorithm_data or kwargs is used in this heuristic.
    
    # Extract necessary information from global_data
    job_operation_time = global_data["job_operation_time"]
    
    # Extract necessary information from state_data
    unfinished_jobs = state_data["unfinished_jobs"]
    current_solution = state_data["current_solution"]
    
    # Initialize variables to keep track of the job with the longest next operation time
    max_time = -1
    selected_job = None
    
    # Iterate through all unfinished jobs to find the job with the longest next operation time
    for job_id in unfinished_jobs:
        next_operation_index = current_solution.job_operation_index[job_id]
        
        # Check if there is a next operation for the job
        if next_operation_index < len(job_operation_time[job_id]):
            next_operation_time = job_operation_time[job_id][next_operation_index]
            
            # Update the job with the longest next operation time
            if next_operation_time > max_time:
                max_time = next_operation_time
                selected_job = job_id
    
    # If no job is found (all jobs are finished), return None and an empty dictionary
    if selected_job is None:
        return None, {}
    
    # Create an AdvanceOperator for the job with the longest next operation time
    operator = AdvanceOperator(selected_job)
    
    # Return the operator and an empty dictionary since no algorithm data is updated
    return operator, {}
from src.problems.jssp.components import Solution, AdvanceOperator
import random

def random_6512(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:
    """This heuristic randomly selects an unfinished job and advances its next operation in the job's processing sequence.

    Args:
        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:
            - "job_num" (int): The total number of jobs in the problem.
            - "machine_num" (int): The total number of machines in the problem, also as operation num.
            - "job_operation_sequence" (numpy.ndarray): A list of jobs where each job is a list of operations in target sequence.
            - "job_operation_time" (numpy.ndarray):  The time cost for each operation in the target job.
            - "total_processing_times" (list[int]): The total processing time for each machine across all jobs in machine id.
        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:
            - "current_solution" (Solution): An instance of the Solution class representing the current solution.
            - "finished_jobs" (list[int]): List of all finished jobs.
            - "unfinished_jobs" (list[int]): List of all unfinished jobs.
            - "job_operation_index" (list[int]): The index of the next operation to be scheduled for each job.
            - "job_last_operation_end_times" (list[int]): The end time of the last operation for each job in the current solution.
            - "job_states" (pd.DataFrame): DataFrame for job states, columns=["JobID", "IsFinished", "CompletedOperationsForMachinesInSequence(MachineID,StartTime,EndTime)", "RemainingOperationsForMachineInSequence(MachineID)", "EndTimeForLastOperation"]
            - "machine_last_operation_end_times" (list[int]): The end time of the last operation for each machine, also as the available time for next operation.
            - "machine_states" (pd.DataFrame): DataFrame for machine states, columns=["MachineID", "CompletedOperationsForJobsInSequence(JobID,StartTime,EndTime)", "EndTimeForLastOperation"]
            - "current_makespan" (int): The time cost for current operation jobs, also known as the current_makespan.

    Returns:
        AdvanceOperator: The operator to advance the next operation for a randomly selected unfinished job.
        dict: Updated algorithm data (empty in this case).
    """
    # Check if there are any unfinished jobs
    unfinished_jobs = state_data["unfinished_jobs"]
    if not unfinished_jobs:
        return None, {}

    # Randomly select an unfinished job
    selected_job = random.choice(unfinished_jobs)

    # Create an AdvanceOperator for the selected job
    operator = AdvanceOperator(job_id=selected_job)

    # Return the operator and an empty dictionary as no algorithm data is updated
    return operator, {}
from src.problems.jssp.components import ShiftOperator

def shift_operator_109f(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[ShiftOperator, dict]:
    """
    This heuristic attempts to find a better schedule by shifting an operation within the same machine's queue.
    For each machine, it tries shifting each operation to all possible positions and evaluates the makespan.
    The shift that results in the best improvement (reduction in makespan) is selected.

    Args:
        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:
            - "machine_num" (int): The total number of machines.
        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:
            - "current_solution" (Solution): The current solution state.
            - "current_makespan" (int): The current makespan of the schedule.
        get_state_data_function (callable): Function to get the new state data given a Solution instance.

    Returns:
        ShiftOperator: An operator that shifts a job in the schedule to achieve a local improvement.
        dict: An empty dictionary as this heuristic does not require algorithm data updates.
    """

    current_solution = state_data['current_solution']
    machine_num = global_data['machine_num']
    best_operator = None
    best_delta = float('inf')

    # Iterate over all machines
    for machine_id in range(machine_num):
        # Iterate over all operations in the machine's queue
        for current_position, job_id in enumerate(current_solution.job_sequences[machine_id]):
            # Try shifting the operation to all possible positions
            for new_position in range(len(current_solution.job_sequences[machine_id])):
                # Skip if the position is the same as the current one
                if current_position == new_position:
                    continue
                
                # Create a new solution with the operation shifted to the new position
                new_solution = ShiftOperator(machine_id, job_id, new_position).run(current_solution)
                new_state = get_state_data_function(new_solution)
                
                # If the new solution is valid, evaluate its makespan
                if new_state is not None:
                    delta = new_state['current_makespan'] - state_data['current_makespan']
                    
                    # If the makespan is improved, store this operator
                    if delta < best_delta:
                        best_operator = ShiftOperator(machine_id, job_id, new_position)
                        best_delta = delta

    # If a beneficial shift is found, return the corresponding operator
    if best_operator and best_delta < 0:
        return best_operator, {}
    else:
        return None, {}
from src.problems.jssp.components import AdvanceOperator

def shortest_job_next_5b42(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[AdvanceOperator, dict]:
    """Implements the Shortest Job Next heuristic for the Job Shop Scheduling Problem.
    This heuristic chooses the unfinished job with the shortest remaining processing time and advances its next operation.

    Args:
        global_data (dict): Contains global static information about the problem.
            - "job_operation_time" (numpy.ndarray):  The time cost for each operation in each job.
            
        state_data (dict): Contains the current state information of the solution.
            - "unfinished_jobs" (list[int]): List of all unfinished jobs.
            - "current_solution" (Solution): The current solution state.
            
        algorithm_data (dict): Contains data necessary for the algorithm's state, not used in this heuristic.
        get_state_data_function (callable): A function to get the state data for a given solution.

    Returns:
        AdvanceOperator: The operator to advance the next operation of the selected job.
        dict: An empty dictionary as this heuristic does not update algorithm data.
    """

    # Retrieve the necessary information from the global and state data
    job_operation_time = global_data["job_operation_time"]
    unfinished_jobs = state_data["unfinished_jobs"]
    job_operation_index = state_data["current_solution"].job_operation_index

    # Check if there are any unfinished jobs
    if not unfinished_jobs:
        return None, {}

    # Calculate the total remaining processing time for each unfinished job
    remaining_times = {job: sum(times[job_operation_index[job]:]) 
                       for job, times in enumerate(job_operation_time) if job in unfinished_jobs}

    # Find the job with the shortest total remaining processing time
    shortest_job = min(remaining_times, key=remaining_times.get)

    # Generate the operator to advance the selected job
    operator = AdvanceOperator(job_id=shortest_job)

    return operator, {}
from src.problems.jssp.components import Solution, SwapOperator

def _2opt_f9c1(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[SwapOperator, dict]:
    """Implements a 2-opt heuristic for the Job Shop Scheduling Problem (JSSP).
    This heuristic attempts to reduce the makespan by swapping two non-adjacent operations in the schedule.
    It iteratively checks all possible pairs of operations to determine if a shorter sequence can be found.

    Args:
        global_data (dict): The global data dict containing the global data. In this algorithm, the following items are necessary:
            - "job_operation_sequence" (numpy.ndarray): Each job's sequence of operations.
            - "machine_num" (int): The total number of machines.
        state_data (dict): The state dictionary containing the current state information. In this algorithm, the following items are necessary:
            - "current_solution" (Solution): The current solution state.
            - "job_operation_index" (list[int]): The index of the next operation to be scheduled for each job.

    Returns:
        (SwapOperator, dict): A tuple where the first element is the selected operator that performs the best swap found,
                              and the second element is an empty dictionary since this algorithm does not update algorithm_data.
    """
    current_solution = state_data['current_solution']
    job_operation_sequence = global_data['job_operation_sequence']
    machine_num = global_data['machine_num']
    best_operator = None
    best_delta = 0

    # Iterating over all machines and all non-adjacent pairs of jobs within each machine's sequence
    for machine_id in range(machine_num):
        for i in range(len(current_solution.job_sequences[machine_id]) - 2):
            for j in range(i + 2, len(current_solution.job_sequences[machine_id])):
                job_id1 = current_solution.job_sequences[machine_id][i]
                job_id2 = current_solution.job_sequences[machine_id][j]

                # Calculate the makespan change if the swap is performed
                new_solution = SwapOperator(machine_id, job_id1, job_id2).run(current_solution)
                new_state = get_state_data_function(new_solution)
                if new_state == None:
                    continue
                delta = new_state['current_makespan'] - state_data['current_makespan']

                # Check if this is the best swap found so far
                if best_operator is None or delta < best_delta:
                    best_operator = SwapOperator(machine_id, job_id1, job_id2)
                    best_delta = delta

    # If a beneficial swap is found, return the corresponding operator
    if best_operator and best_delta < 0:
        return best_operator, {}
    else:
        return None, {}
from src.problems.jssp.components import Solution, SwapOperator

def _3opt_6ee0(global_data: dict, state_data: dict, algorithm_data: dict, get_state_data_function: callable, **kwargs) -> tuple[SwapOperator, dict]:
    """3-opt heuristic for Job Shop Scheduling Problem (JSSP).
    This function does not generate a complete 3-opt operator since JSSP requires operations within a job to be executed in sequence and does not allow reordering of these operations.The heuristic is adapted to generate a series of 2-opt swaps (using the SwapOperator) which approximate a 3-opt move.

    Args:
        global_data (dict): The global data dict containing the global data.
            - "machine_num" (int): The total number of machines.
            - "job_num" (int): The total number of jobs.
            
        state_data (dict): The state dictionary containing the current state information.
            - "current_solution" (Solution): The current solution state.
            - "unfinished_jobs" (list[int]): List of all unfinished jobs.
            - "machine_last_operation_end_times" (list[int]): The end time of the last operation for each machine.
            
        algorithm_data (dict): Not used in this heuristic.
        
        get_state_data_function (callable): Function to get the new state data given a Solution instance.
    
    Returns:
        SwapOperator: The operator to swap two jobs in the schedule.
        dict: Empty dictionary as no algorithm data is updated.
    """
    
    # Check if we have enough jobs to perform a 3-opt move
    if global_data['job_num'] < 3:
        return None, {}  # Not enough jobs to perform a 3-opt
    
    # Extract necessary information from the state data
    current_solution = state_data['current_solution']
    machine_last_operation_end_times = state_data['machine_last_operation_end_times']
    
    # Initialize variables to store the best swap operator and its corresponding makespan improvement
    best_operator = None
    best_improvement = 0
    
    # Iterate over all machines
    for machine_id in range(global_data['machine_num']):
        job_sequence = current_solution.job_sequences[machine_id]
        num_jobs = len(job_sequence)
        
        # Need at least three jobs on the machine to consider 3-opt
        if num_jobs < 3:
            continue
        
        # Consider all triplets of jobs for potential 3-opt moves
        for i in range(num_jobs - 2):
            for j in range(i + 1, num_jobs - 1):
                for k in range(j + 1, num_jobs):
                    # Perform 2-opt swaps and check for improvement
                    new_solution = SwapOperator(machine_id, job_sequence[i], job_sequence[k]).run(current_solution)
                    new_state = get_state_data_function(new_solution)
                    if new_state == None:
                        continue
                    improvement = state_data['current_makespan'] - new_state['current_makespan']
                    
                    # Update the best operator if this swap results in a better makespan
                    if improvement > best_improvement:
                        best_improvement = improvement
                        best_operator = SwapOperator(machine_id, job_sequence[i], job_sequence[k])
    
    # Return the best operator found (if any) and an empty dictionary as no algorithm data is updated
    return best_operator, {}

Before we solve the actual problem, we hope to select useful algorithms and classify them so that we can use different algorithms in different scenarios. 
We hope to classify algorithms and use different algorithms in different scenarios. 
Please note:
1. We only hope to sort useful and powerful heuristic, some heuristic are not powerful, such pure random heuristic;
2. One heuristic can belong to multiple classification;
3. Detailed classification is welcome.

The response format is very important. For better communication, please respond to me in this format:
***heuristic_classification:
classification1:heuristic_name_1,heuristic_name_2,...;reason
classification2:heuristic_name_3,heuristic_name_4,...;reason
....
***
Ensure there is no other content inside the ***, and analysis outside *** are welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***heuristic_classification:
priority_based:first_come_first_served_af26,most_work_remaining_df20,shortest_processing_time_first_d471,longest_job_next_2e23,longest_processing_time_first_9dc9,shortest_job_next_5b42;these heuristics prioritize jobs based on specific metrics like processing time, work remaining, or job length, making them suitable for scenarios where job prioritization is crucial.
local_optimization:shift_operator_109f,_2opt_f9c1,_3opt_6ee0;these heuristics focus on local optimization techniques, such as shifting operations or performing 2-opt and 3-opt swaps, making them effective in scenarios where small adjustments can lead to significant improvements in the schedule.
randomized:random_6512;this heuristic introduces randomness in job selection, which can be useful for escaping local optima but is generally less powerful due to its lack of strategic decision-making.
complexity_adaptive:first_come_first_served_af26,most_work_remaining_df20,shortest_processing_time_first_d471;these heuristics incorporate dynamic adjustments based on complexity measures like job diversity or iteration count, making them adaptable to different problem complexities and dataset characteristics.
***
------------------------------------------------------------------------------------

